<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/13/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/13/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><br>title: LockSupport的使用和基本原理<br>date: 2024<span class="hljs-string">-04</span><span class="hljs-string">-13</span> 19:20:33<br><span class="hljs-keyword">tags:</span><br> - java<br> - juc<br> - 多线程<br>categories<br>- juc<br><br></code></pre></td></tr></table></figure><h1 id="LockSupport的使用和基本原理"><a href="#LockSupport的使用和基本原理" class="headerlink" title="LockSupport的使用和基本原理"></a>LockSupport的使用和基本原理</h1><h2 id="1、wait和notify-x2F-notifyAll-限制"><a href="#1、wait和notify-x2F-notifyAll-限制" class="headerlink" title="1、wait和notify&#x2F;notifyAll 限制"></a>1、<strong>wait</strong>和<strong>notify</strong>&#x2F;<strong>notifyAll</strong> 限制</h2><ul><li>必须包含在 synchronized代码块里面。否则导致IllegalMonitorStateException。<br> 可以这么理解，wait是必须要释放当前线程的锁，如果一个代码块没有拿到锁，那么wait也就没有了意义。</li><li>必须先wait，再notify才可以唤醒阻塞的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">// 定义一个对象，充当锁。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待并且释放锁</span><br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(sum);<br>        &#125;<br>    &#125;);<br><br>    a.start();<br>    <span class="hljs-comment">// 睡眠一秒钟，保证A线程已经计算完成。阻塞在wait方法上，防止main线程执行太快，提前发出了notify.</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// wati,和notify 必须包含在 synchronized 代码块里面</span><br>   <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.notify();<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>错误示例1： 先notify再进行wait</strong></p><p>实际上代码就是删掉了sleep</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">// 定义一个对象，充当锁。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待并且释放锁</span><br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(sum);<br>        &#125;<br>    &#125;);<br><br>    a.start();<br>    <span class="hljs-comment">// wati,和notify 必须包含在 synchronized 代码块里面</span><br>   <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.notify();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候提前发出了通知，将导致，线程a,始终在wait,因为已经没有线程给他通知了。</p><p>为了是我们的代码看起来更加简洁，易读。jdk给我们开发LockSupport.</p><h2 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h2><p>   LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。<br>   LockSupport类使用了一种名为Permit(许可)的概念来做到阻塞和唤醒线程的功能,每个线程都有一个许可(permit),permit只有两个值1和零,默认是零</p><p>   <strong>部分源码</strong> </p><p>   里面有相当一部分的native操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    <span class="hljs-comment">// Hotspot implementation via intrinsics API</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> parkBlockerOffset;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SEED;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> PROBE;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SECONDARY;<br>    <br>    <span class="hljs-comment">//静态初始化代码块，</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取Unsafe实例</span><br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            <span class="hljs-comment">// 线程类类型</span><br>            Class&lt;?&gt; tk = Thread.class;<br>            <span class="hljs-comment">// 获取Thread的parkBlocker字段的内存偏移地址</span><br>            parkBlockerOffset = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;parkBlocker&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomSeed字段的内存偏移地址</span><br>            SEED = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSeed&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomProbe字段的内存偏移地址</span><br>            PROBE = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomProbe&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址</span><br>            SECONDARY = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSecondarySeed&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LockSupport中的方法<br><img src="https://img-blog.csdnimg.cn/direct/b347a036d85d44ba99175a57660ba7a9.png" alt="在这里插入图片描述">重点在于以下两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAbsolute, <span class="hljs-type">long</span> time)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br></code></pre></td></tr></table></figure><p>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞:<br>① 调用unpark函数，释放该线程的许可。<br>② 该线程被中断。<br>③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活</p><p>LockSupport示例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (() -&gt; &#123;<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;开始运行&quot;</span>);<br>        LockSupport.park ();<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;解除park&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;线程一&quot;</span>);<br>    <br>    t1.start ();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (() -&gt; &#123;<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;开始运行&quot;</span>);<br>        LockSupport.unpark (t1);<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;解除线程一的park&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;线程二&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">线程二开始运行<br>线程一开始运行<br>线程二解除线程一的park<br>线程一解除park<br></code></pre></td></tr></table></figure><p>注意观察，LockSupport只需要在该停止的地方park一下，不需要创建任何锁的对象，也不需要关注是否该线程拥有锁，只需要LockSupport.park().然后静静等待通知。<br>还有一点值得注意的是，我们通过观察结果发现，线程二先开始运行，意味着它先一步通知了，但是线程一没有卡住，仍然收到了通知。解除了park.<br>这就是他的优秀之处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/10/19/risc-vOS%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/19/risc-vOS%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>学习资料：</p><p>gdb调试   <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">linuxtools</a></p><p>make 小知识 </p><p>​1   利用-n 可以看到详细的makefile的输出</p><p>寄存器小知识</p><blockquote><p>RISC-V 架构中有一组通用寄存器（General-Purpose Registers），它们通常用于存储整数数据和执行算术操作。以下是一些常见的 RISC-V 通用寄存器及其典型的作用：</p><ol><li><strong>x0</strong>：零寄存器，总是包含值0。在某些情况下，也被称为<code>zero</code>寄存器。</li><li><strong>x1</strong>：保留寄存器，用于汇编器、链接器等工具。</li><li><strong>x2</strong> - <strong>x11</strong>：临时寄存器，通常用于存储临时数据和计算结果。</li><li><strong>x12</strong> - <strong>x17</strong>：保存寄存器（s0 - s5），通常用于保存函数调用期间的寄存器值，以便在函数返回后能够正确恢复。</li><li><strong>x18</strong> - <strong>x27</strong>：临时寄存器，类似于 x2 - x11，用于存储临时数据。</li><li><strong>x28</strong> - <strong>x31</strong>：临时寄存器，通常用于存储临时数据和计算结果。</li></ol><p>除了通用寄存器，RISC-V 架构还包括一些特殊寄存器，这些寄存器在特定的操作和功能中发挥重要作用，例如：</p><ul><li><strong>pc</strong>：程序计数器，用于存储当前指令的地址，控制程序的执行顺序。</li><li><strong>sp</strong>：栈指针，用于管理函数调用期间的堆栈。</li><li><strong>gp</strong>：全局指针，通常用于访问全局数据。</li><li><strong>tp</strong>：线程指针，用于多线程环境中跟踪线程相关的数据。</li><li><strong>fp</strong>：帧指针，用于存储函数的栈帧信息。</li><li><strong>ra</strong>：返回地址寄存器，用于存储函数返回时的返回地址。</li><li><strong>a0</strong> - <strong>a7</strong>：参数寄存器，用于传递函数参数。</li><li><strong>t0</strong> - <strong>t6</strong>：临时寄存器，类似于通用寄存器，用于存储临时数据和计算结果。</li><li><strong>sstatus</strong>：状态寄存器，用于控制和管理处理器的状态，如中断和异常处理。</li><li><strong>stvec</strong>：中断向量寄存器，指示中断处理程序的入口地址。</li><li><strong>sie</strong>：中断使能寄存器，用于允许或禁止中断的发生。</li><li><strong>sip</strong>：中断挂起寄存器，用于标记中断请求的状态。</li><li><strong>mstatus</strong>：机器模式状态寄存器，类似于 <code>sstatus</code>，但用于机器模式下。</li><li><strong>mcause</strong>：机器模式异常原因寄存器，存储最近的异常原因。</li><li><strong>mtvec</strong>：机器模式中断向量寄存器，指示异常处理程序的入口地址。</li><li><strong>mepc</strong>：机器模式程序计数器，用于保存机器模式下的程序计数器值。</li></ul><p>这些寄存器在 RISC-V 架构中的不同模式下（用户模式、机器模式等）具有不同的行为和作用，但通常用于管理程序的执行、存储数据和处理中断与异常等任务。</p></blockquote><h3 id="00-bootstrap"><a href="#00-bootstrap" class="headerlink" title="00-bootstrap"></a>00-bootstrap</h3><p>这个项目下总共有四个文件夹分别是</p><p>首先看.h文件</p><h4 id="platform-h"><a href="#platform-h" class="headerlink" title="platform.h"></a>platform.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __PLATFORM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PLATFORM_H__</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * QEMU RISC-V Virt machine with 16550a UART and VirtIO MMIO</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * maximum number of CPUs</span><br><span class="hljs-comment"> * see https://github.com/qemu/qemu/blob/master/include/hw/riscv/virt.h</span><br><span class="hljs-comment"> * #define VIRT_CPUS_MAX 8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM_CPU 8 <span class="hljs-comment">//这里的 8 应该是对应的hart的数量</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __PLATFORM_H__ */</span></span><br></code></pre></td></tr></table></figure><h4 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h4><p>注意是大写的S,可以包含#include 等指令，小写的则不行，它的作用是，在进入C语言的main函数中，初始化一些内容，比如hart的栈空间，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &quot;platform.h&quot;  //将.h文件包含<br><br># size of each hart&#x27;s stack is 1024 bytes<br>.equSTACK_SIZE, 1024 #.equ是汇编器识别的伪指令，作用是定义一个symble lable，值为1024<br><br>#定义全局的标签，是给链接器看的，告诉qemu从这里开始执行第一条指令<br>.global_start<br><br>.text<br>_start:<br># park harts with id != 0<br><br>#csrr是专门用来访问状态寄存器的<br><br>csrrt0, mhartid# read current hart id<br>mvtp, t0# keep CPU&#x27;s hartid in its tp for later usage.<br>bnezt0, park# if we&#x27;re not on the hart 0<br># we park the hart<br># Setup stacks, the stack grows from bottom to top, so we put the<br># stack pointer to the very end of the stack range.<br><br>//后面这些指令是为了不同的hart设置不同的栈空间，但是应该用不上<br>sllit0, t0, 10# shift left the hart id by 1024<br>lasp, stacks + STACK_SIZE# set the initial stack pointer<br># to the end of the first stack space<br>addsp, sp, t0# move the current hart stack pointer<br># to its place in the stack space<br><br>jstart_kernel# hart 0 jump to c<br><br>park:<br>wfi //是一种用来休眠的指令，避免空转耗电<br>jpark<br><br>stacks:<br>.skipSTACK_SIZE * MAXNUM_CPU # allocate space for all the harts stacks<br><br>.end# End of file<br><br></code></pre></td></tr></table></figure><h4 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//跳进来了以后开始空转</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;; <span class="hljs-comment">// stop here!</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>makefile 的输出</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">riscv64-unknown-elf-gcc \<br>-nostdlib \<br>-fno-builtin \<br>-march=rv32ima \ <br>-mabi=ilp32 \ <br>-g <br>-Wall <br>-c <br>-o start.o start.S<br><br></code></pre></td></tr></table></figure><blockquote><p>这是一个编译命令，用于将 RISC-V 32位体系结构的汇编文件 <code>start.S</code> 编译成目标文件 <code>start.o</code>。以下是对该命令的各个部分的解释：</p><ul><li><p><code>riscv64-unknown-elf-gcc</code>: 这是 RISC-V 交叉编译工具链（Cross-Compiler）的命令前缀。<code>riscv64-unknown-elf-gcc</code> 表示使用的是针对 RISC-V 体系结构的交叉编译器。这个编译器可用于编译 RISC-V 架构的程序。</p></li><li><p><code>-nostdlib</code>: 这是一个编译选项，指示编译器不要链接标准 C 库。通常，嵌入式系统或嵌入式应用程序可能不需要完整的标准库，因此可以使用此选项来禁用标准库的链接。</p></li><li><p><code>-fno-builtin</code>: 这也是一个编译选项，用于禁用内建函数（Builtin Functions）的使用。内建函数是编译器内置的一些函数，它们通常用于执行特定操作，如优化。使用此选项可以禁用这些内建函数。</p></li><li><p><code>-march=rv32ima</code>: 这是一个编译选项，指定了目标架构。在这里，<code>-march=rv32ima</code> 表示目标架构是 RISC-V 32位，支持整数（i）、乘法扩展（m）和原子操作扩展（a）指令集。</p></li><li><p><code>-mabi=ilp32</code>: 这是另一个编译选项，指定了目标 ABI（Application Binary Interface）。<code>ilp32</code> 表示整数类型、寄存器和地址都是32位的。这与 <code>lp64</code>（长整数类型、寄存器和地址为64位）等不同的 ABI 有关。</p></li><li><p><code>-g</code>: 这是一个编译选项，用于生成调试信息。它会在目标文件中嵌入调试信息，以便在后续调试程序时使用。</p></li><li><p><code>-Wall</code>: 这是一个编译选项，用于启用编译器的警告。编译器将生成警告消息，以帮助开发人员识别潜在的问题或错误。</p></li><li><p><code>-c</code>: 这是一个编译选项，指示编译器仅生成目标文件，而不进行链接操作。生成的目标文件通常具有 <code>.o</code> 扩展名。</p></li><li><p><code>-o start.o</code>: 这是一个编译选项，指定生成的目标文件的名称。在这里，生成的目标文件将命名为 <code>start.o</code>。</p></li></ul><p>总的来说，这个编译命令用于将 RISC-V 32位汇编文件 <code>start.S</code> 编译成目标文件 <code>start.o</code>，使用了特定的目标架构和 ABI，并启用了调试信息和警告。这是编译一个 RISC-V 32位汇编程序的标准命令。后续可以使用该目标文件进行链接操作，以创建可执行文件。</p></blockquote><h3 id="01-HelloRVOS"><a href="#01-HelloRVOS" class="headerlink" title="01-HelloRVOS"></a>01-HelloRVOS</h3><p>想办法打印出一个hello world</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>学习记录2023/10/19</title>
    <link href="/2023/10/19/leetcode1343/"/>
    <url>/2023/10/19/leetcode1343/</url>
    
    <content type="html"><![CDATA[<h3 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h3><p>学习了一下什么是滑动窗口，<a href="https://algo.itcharge.cn/01.Array/05.Array-Sliding-Window/01.Array-Sliding-Window/">学习地址</a></p><p>适合解决的数组连续区间的问题</p><p>模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">left = <span class="hljs-number">0</span><br>right = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> right &lt; len(nums):<br>    window.append(nums[right])<br>    <br>    # 超过窗口大小时，缩小窗口，维护窗口中始终为 window_size 的长度<br>    <span class="hljs-keyword">if</span> right - left + <span class="hljs-number">1</span> &gt;= window_size:<br>        # ... 维护答案<br>        window.popleft()<br>        left += <span class="hljs-number">1</span><br>    <br>    # 向右侧增大窗口<br>    right += <span class="hljs-number">1</span><br>    <br><br></code></pre></td></tr></table></figure><p>例题：</p><p><a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/">1343. 大小为 K 且平均值大于等于阈值的子数组数目 - 力扣（LeetCode）</a></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="Z:\hexo-blog\source_posts\leetcode1343\leetcode1343.png" alt="image-20231019191907752"></h4><p>要求我们满足一定的条件的区间个数</p><p>按照模板，初始化<code>left=0,right=0</code></p><p>一开始区间肯定是空的，应该先无脑将区间填满。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numOfSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; arr.length) &#123;<br><span class="hljs-comment">//无脑填满</span><br>            sum += arr[right];<br>            <span class="hljs-comment">//判断是不是填满了，如果填满了是不是满足条件，</span><br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &gt;= k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> sum / k;<br>                <span class="hljs-keyword">if</span> (average &gt;=threshold) &#123;<br>                    res++;<br>                &#125;<br>                <span class="hljs-comment">//无论满不满足，这个区间已经没用了，开发下一个区间</span><br>                sum -= arr[left];<br>                left++;<br>            &#125;<br>            <span class="hljs-comment">//因为上面判断是用right-left+1，因此right++要放在判断的后面</span><br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git push results in &quot;Authentication Failed&quot;可能的解决方法</title>
    <link href="/2023/06/03/Authentication%20Failed%E5%8F%AF%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/03/Authentication%20Failed%E5%8F%AF%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>事情是这样的，手贱改了下github的名字，并且<strong>申请了个人的token</strong>。</p><p>问题应该就出在这里。</p><p>然后当我再次push的时候，一直提示Authentication Failed。</p><p>我就纳了闷了。难道是我密码输错了吗？然后又开始重新输入。</p><p>最后在<a href="https://stackoverflow.com/questions/17659206/git-push-results-in-authentication-failed">stackoverflow</a>这里找到了答案。</p><p>stackoverflow高赞答案: <img src="https://img-blog.csdnimg.cn/71886d2a3fe9483cbc7f1c00c027c4e6.png" alt="stackoverflow高赞答案"></p><p><strong>翻译一下</strong>：</p><blockquote><p>如果您在 GitHub 帐户中启用了双因素身份验证，您将无法使用您的帐户密码通过 HTTPS 进行推送。相反，您需要生成个人访问令牌。这可以在您的 GitHub 帐户的应用程序设置中完成。使用此令牌作为密码应该允许您通过 HTTPS 推送到远程存储库。像往常一样使用您的用户名。</p></blockquote><p><strong>再翻译一下</strong>：</p><p><code>使用你的个人的token代替之前的密码</code></p><blockquote><p>一天的光阴，能够写进我们记忆中的并不多，能够为人生带来些助益的，也不见得有多少。我们一直在求有所得，但却每一分每一秒都在错过。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>problems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown编辑器的使用</title>
    <link href="/2023/06/02/test/"/>
    <url>/2023/06/02/test/</url>
    
    <content type="html"><![CDATA[<h2 id="欢迎使用Markdown编辑器"><a href="#欢迎使用Markdown编辑器" class="headerlink" title="欢迎使用Markdown编辑器"></a>欢迎使用Markdown编辑器</h2><p>你好！ 这是你第一次使用 <strong>Markdown编辑器</strong> 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。</p><h2 id="新的改变"><a href="#新的改变" class="headerlink" title="新的改变"></a>新的改变</h2><p>我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：</p><ol><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；</li><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[mermaid语法说明](https://mermaidjs.github.io/)"><a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">1</a></span></a></sup></strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol><h2 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h2><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h2 id="合理的创建标题，有助于目录的生成"><a href="#合理的创建标题，有助于目录的生成" class="headerlink" title="合理的创建标题，有助于目录的生成"></a>合理的创建标题，有助于目录的生成</h2><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h2 id="如何改变文本的样式"><a href="#如何改变文本的样式" class="headerlink" title="如何改变文本的样式"></a>如何改变文本的样式</h2><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h2 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h2><p>链接: <a href="https://www.csdn.net/">link</a>.</p><p>图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw" alt="hhhhh"></p><p>带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw</a> &#x3D;30x30)</p><p>居中的图片: <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center" alt="Alt"></p><p>居中并且带尺寸的图片: ![Alt](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center</a> &#x3D;30x30)</p><p>当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。</p><h2 id="如何插入一段漂亮的代码片"><a href="#如何插入一段漂亮的代码片" class="headerlink" title="如何插入一段漂亮的代码片"></a>如何插入一段漂亮的代码片</h2><p>去<a href="https://mp.csdn.net/console/configBlog">博客设置</a>页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 <code>代码片</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// An highlighted block</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="生成一个适合你的列表"><a href="#生成一个适合你的列表" class="headerlink" title="生成一个适合你的列表"></a>生成一个适合你的列表</h2><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled="" type="checkbox"> 计划任务</li><li><input checked="" disabled="" type="checkbox"> 完成任务</li></ul><h2 id="创建一个表格"><a href="#创建一个表格" class="headerlink" title="创建一个表格"></a>创建一个表格</h2><p>一个简单的表格是这么创建的：</p><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h3 id="设定内容居中、居左、居右"><a href="#设定内容居中、居左、居右" class="headerlink" title="设定内容居中、居左、居右"></a>设定内容居中、居左、居右</h3><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="right">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="right">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h3 id="SmartyPants"><a href="#SmartyPants" class="headerlink" title="SmartyPants"></a>SmartyPants</h3><p>SmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：</p><table><thead><tr><th>TYPE</th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>– is en-dash, — is em-dash</td></tr></tbody></table><h2 id="创建一个自定义列表"><a href="#创建一个自定义列表" class="headerlink" title="创建一个自定义列表"></a>创建一个自定义列表</h2><dl><dt>Markdown</dt><dd>Text-to-HTML conversion tool</dd></dl><dl><dt>Authors<br>:  John</dt><dd>Luke</dd></dl><h2 id="如何创建一个注脚"><a href="#如何创建一个注脚" class="headerlink" title="如何创建一个注脚"></a>如何创建一个注脚</h2><p>一个具有注脚的文本。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="注脚的解释"><a href="https://mermaidjs.github.io/">2</a></span></a></sup></p><h2 id="注释也是必不可少的"><a href="#注释也是必不可少的" class="headerlink" title="注释也是必不可少的"></a>注释也是必不可少的</h2><p>Markdown将文本转换为 HTML。</p><p>*[HTML]:   超文本标记语言</p><h2 id="KaTeX数学公式"><a href="#KaTeX数学公式" class="headerlink" title="KaTeX数学公式"></a>KaTeX数学公式</h2><p>您可以使用渲染LaTeX数学表达式 <a href="https://khan.github.io/KaTeX/">KaTeX</a>:</p><p>Gamma公式展示 $\Gamma(n) &#x3D; (n-1)!\quad\forall<br>n\in\mathbb N$ 是通过欧拉积分</p><p>$$<br>\Gamma(z) &#x3D; \int_0^\infty t^{z-1}e^{-t}dt,.<br>$$</p><blockquote><p>你可以找到更多关于的信息 <strong>LaTeX</strong> 数学表达式<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h2 id="新的甘特图功能，丰富你的文章"><a href="#新的甘特图功能，丰富你的文章" class="headerlink" title="新的甘特图功能，丰富你的文章"></a>新的甘特图功能，丰富你的文章</h2><pre><code class=" mermaid">gantt        dateFormat  YYYY-MM-DD        title Adding GANTT diagram functionality to mermaid        section 现有任务        已完成               :done,    des1, 2014-01-06,2014-01-08        进行中               :active,  des2, 2014-01-09, 3d        计划一               :         des3, after des2, 5d        计划二               :         des4, after des3, 5d</code></pre><ul><li>关于 <strong>甘特图</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="UML-图表"><a href="#UML-图表" class="headerlink" title="UML 图表"></a>UML 图表</h2><p>可以使用UML图表进行渲染。 <a href="https://mermaidjs.github.io/">Mermaid</a>. 例如下面产生的一个序列图：</p><pre><code class=" mermaid">sequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四--&gt;&gt;王五: 你最近怎么样，王五？李四--x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.李四--&gt;&gt;张三: 打量着王五...张三-&gt;&gt;王五: 很好... 王五, 你怎么样?</code></pre><p>这将产生一个流程图。:</p><pre><code class=" mermaid">graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D</code></pre><ul><li>关于 <strong>Mermaid</strong> 语法，参考 <a href="https://mermaidjs.github.io/">这儿</a>,</li></ul><h2 id="FLowchart流程图"><a href="#FLowchart流程图" class="headerlink" title="FLowchart流程图"></a>FLowchart流程图</h2><p>我们依旧会支持flowchart的流程图：</p><pre><code class=" mermaid">flowchatst=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><ul><li>关于 <strong>Flowchart流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 <strong>文章导出</strong> ，生成一个.md文件或者.html文件进行本地保存。</p><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，<br>继续你的创作。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://mermaidjs.github.io/">mermaid语法说明</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>注脚的解释<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/02/hello-world/"/>
    <url>/2023/06/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$hexo</span> new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$hexo</span> server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
