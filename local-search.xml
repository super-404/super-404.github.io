<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/27/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
    <url>/2024/10/27/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="完全背包变形问题"><a href="#完全背包变形问题" class="headerlink" title="完全背包变形问题"></a>完全背包变形问题</h1><h1 id="P2918-USACO08NOV-Buying-Hay-S"><a href="#P2918-USACO08NOV-Buying-Hay-S" class="headerlink" title="P2918 [USACO08NOV] Buying Hay S"></a>P2918 [USACO08NOV] Buying Hay S</h1><p>约翰的干草库存已经告罄，他打算为奶牛们采购 H(1≤H≤50000)<em>H</em>(1≤<em>H</em>≤50000) 磅干草。</p><p>他知道 N(1≤N≤100)<em>N</em>(1≤<em>N</em>≤100) 个干草公司，现在用 11 到 N<em>N</em> 给它们编号。第 i<em>i</em> 公司卖的干草包重量为 Pi(1≤Pi≤5,000)<em>P**i</em>(1≤<em>P**i</em>≤5,000) 磅，需要的开销为 Ci(1≤Ci≤5,000)<em>C**i</em>(1≤<em>C**i</em>≤5,000) 美元。每个干草公司的货源都十分充足， 可以卖出无限多的干草包。</p><p>帮助约翰找到最小的开销来满足需要，即采购到至少 H 磅干草。</p><p><strong>Notice:</strong></p><p>因为要求是至少H磅，所有正确答案可能存在于 &gt;&#x3D;H 磅中，因此DP数组需要开大一些，至少是max*n</p><h1 id="CSP-J2019-纪念品"><a href="#CSP-J2019-纪念品" class="headerlink" title="[CSP-J2019] 纪念品"></a>[CSP-J2019] 纪念品</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小伟突然获得一种超能力，他知道未来 $T$ 天 $N$ 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。</p><p>每天，小伟可以进行以下两种交易<strong>无限次</strong>：</p><ol><li>任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；</li><li>卖出持有的任意一个纪念品，以当日价格换回金币。</li></ol><p>每天卖出纪念品换回的金币可以<strong>立即</strong>用于购买纪念品，当日购买的纪念品也可以<strong>当日卖出</strong>换回金币。当然，一直持有纪念品也是可以的。</p><p>$T$ 天之后，小伟的超能力消失。因此他一定会在第 $T$ 天卖出<strong>所有</strong>纪念品换回金币。</p><p>小伟现在有 $M$ 枚金币，他想要在超能力消失后拥有尽可能多的金币。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个正整数 $T, N, M$，相邻两数之间以一个空格分开，分别代表未来天数 $T$，纪念品数量 $N$，小伟现在拥有的金币数量 $M$。</p><p>接下来 $T$ 行，每行包含 $N$ 个正整数，相邻两数之间以一个空格分隔。第 $i$ 行的 $N$ 个正整数分别为 $P_{i,1},P_{i,2},\dots,P_{i,N}$，其中 $P_{i,j}$ 表示第 $i$ 天第 $j$ 种纪念品的价格。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">1</span> <span class="hljs-number">100</span><br><span class="hljs-number">50</span><br><span class="hljs-number">20</span><br><span class="hljs-number">25</span><br><span class="hljs-number">20</span><br><span class="hljs-number">25</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">305<br></code></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">100</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">20</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">17</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">25</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">217<br></code></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>样例 1 说明</strong></p><p>最佳策略是：</p><p>第二天花光所有 $100$ 枚金币买入 $5$ 个纪念品 $1$；</p><p>第三天卖出 $5$ 个纪念品 $1$，获得金币 $125$ 枚；</p><p>第四天买入 $6$ 个纪念品 $1$，剩余 $5$ 枚金币；</p><p>第六天必须卖出所有纪念品换回 $300$ 枚金币，第四天剩余 $5$ 枚金币，共 $305$ 枚金币。</p><p>超能力消失后，小伟最多拥有 $305$ 枚金币。</p><p><strong>样例 2 说明</strong></p><p>最佳策略是：</p><p>第一天花光所有金币买入 $10$ 个纪念品 $1$；</p><p>第二天卖出全部纪念品 $1$ 得到 $150$ 枚金币并买入 $8$ 个纪念品 $2$ 和 $1$ 个纪念品 $3$，剩余 $1$ 枚金币；</p><p>第三天必须卖出所有纪念品换回 $216$ 枚金币，第二天剩余 $1$ 枚金币，共 $217$ 枚金币。</p><p>超能力消失后，小伟最多拥有 $217$ 枚金币。</p><p><strong>数据规模与约定</strong></p><p>对于 $10%$ 的数据，$T &#x3D; 1$。</p><p>对于 $30%$ 的数据，$T \leq 4, N \leq 4, M \leq 100$，所有价格 $10 \leq P_{i,j} \leq 100$。</p><p>另有 $15%$ 的数据，$T \leq 100, N &#x3D; 1$。</p><p>另有 $15%$ 的数据，$T &#x3D; 2, N \leq 100$。</p><p>对于 $100%$ 的数据，$T \leq 100, N \leq 100, M \leq 10^3$，所有价格 $1 \leq P_{i,j} \leq 10^4$，数据保证任意时刻，小伟手上的金币数不可能超过 $10^4$。</p><h1 id="NOIP2018-提高组-货币系统"><a href="#NOIP2018-提高组-货币系统" class="headerlink" title="[NOIP2018 提高组] 货币系统"></a>[NOIP2018 提高组] 货币系统</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2018 提高组 D1T2</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 </p><p>在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n&#x3D;3$, $a&#x3D;[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 </p><p>两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p><p>现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含一个整数 $T$，表示数据的组数。</p><p>接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><br><span class="hljs-symbol">4 </span><br><span class="hljs-symbol">3 </span><span class="hljs-number">19</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <br><span class="hljs-symbol">5 </span><br><span class="hljs-symbol">11 </span><span class="hljs-number">29</span> <span class="hljs-number">13</span> <span class="hljs-number">19</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>  <br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m &lt; 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m &lt; n$ 的等价的货币系统，因此答案为 $5$。 </p><p>【数据范围与约定】</p><p><img src="https://cdn.luogu.com.cn/upload/pic/43160.png">  </p><p>对于 $100%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/26/%E6%B4%9B%E8%B0%B7P3985%20%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E/"/>
    <url>/2024/10/26/%E6%B4%9B%E8%B0%B7P3985%20%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E9%87%91%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="洛谷P3985-不开心的金明"><a href="#洛谷P3985-不开心的金明" class="headerlink" title="洛谷P3985 不开心的金明"></a>洛谷P3985 不开心的金明</h1><h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h2><blockquote><p>原题链接：<a href="https://www.luogu.com.cn/problem/P3985">洛谷P3985 不开心的金明</a></p></blockquote><h2 id="疑惑的来源"><a href="#疑惑的来源" class="headerlink" title="疑惑的来源"></a>疑惑的来源</h2><p>  起初我只是把它当作简单的背包问题，但是观察了数据规模后发现商品的单价vi和限制的总价格w过于庞大，以至于无法开出这么大规模的数组<code>dp[w]</code>，所以解法势必根据数据规模进行优化。而我发现有以下两种解法：</p><h3 id="解法一-优化价格-使用三维数组dp-i-w-k-（恰当的解法）"><a href="#解法一-优化价格-使用三维数组dp-i-w-k-（恰当的解法）" class="headerlink" title="解法一 优化价格 使用三维数组dp[i][w][k]（恰当的解法）"></a>解法一 优化价格 使用三维数组<code>dp[i][w][k]</code>（恰当的解法）</h3><h4 id="优化价格"><a href="#优化价格" class="headerlink" title="优化价格"></a>优化价格</h4><p>  找出商品中的最小价格minp， 然后将每个价格减去最小价格：pi−minp， 由于题目限制商品价格的极差不大于3，那么这样处理过后的商品价格只有p &#x3D; 0,1,2,3这几种情况，所以这个时候最大的商品总价只有3*100 也就是300.</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>反模式的代码审查</title>
    <link href="/2024/10/15/%E5%8F%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"/>
    <url>/2024/10/15/%E5%8F%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.chiark.greenend.org.uk/~sgtatham/quasiblog/code-review-antipatterns/">原文</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>代码审查似乎是个很不错的主意，对吧？两个开发人员查看同一段代码意味着有两次发现问题的机会；它传播了对项目演变方式的理解；审查者可以通过详细阅读作者的代码学习有用的技巧，或发现机会教作者一些他们不知道的有用技巧。</p><p>但这仅仅是对于“光明面”代码审查者而言，他们试图通过审查来改善代码库和开发者的集体技能。代码审查也可以是一个强大的工具，用于完全不同的目的。当一个代码审查者转向“黑暗面”时，他们有大量的方式来阻碍或延迟对代码的改进，惹恼补丁作者或完全打击他们的积极性，或者追求他们自己的其他目标。</p><p>如果您最近才转向“黑暗面”，您可能还没有想到所有的可能性。因此，这里列出了一些代码审查反模式，供那些灵感枯竭的“黑暗面”代码审查者参考。</p><h2 id="往返千次的死亡"><a href="#往返千次的死亡" class="headerlink" title="往返千次的死亡"></a><strong>往返千次的死亡</strong></h2><p>你开始审阅代码。只要发现小问题，你就添加评论指出它。然后你停止继续阅读。</p><p>开发者认真地修复了你指出的小问题，并提交了修改后的补丁。</p><p>你开始阅读新版本。这次你又发现了一个小问题，与第一个无关。其实你本可以在第一次就指出它，但因为没读那么远，所以没有发现。于是你指出这个问题，然后再次停止阅读。</p><p>如此反复，直到开发者失去希望。</p><p>如果你与开发者处在非常不同的时区，自然会有24小时的往返时间，这样补丁的演变速度会慢到极致。如果你们处在相近的时区或同一时区，那么为了让补丁的提交尽可能拖延，你需要安排其他事情让自己忙起来，以便有个合理的借口让每个版本的审阅花上一两天。</p><p>要抵制住说诸如“这看起来好多了”这样的诱惑性评论。如果你暗示自己快要满意了，开发者就会有继续努力的理由！</p><h2 id="勒索信"><a href="#勒索信" class="headerlink" title="勒索信"></a><strong>勒索信</strong></h2><p>这个特定的补丁对提交的开发者来说似乎特别重要。（也许他们直接说了这点，作为试图说服你接受补丁的理由，或者你从字里行间读出了这种意思。）</p><p>但这个补丁对你来说并不是特别重要——因此你处于一个有利的位置！现在你可以把他们迫切需要的修改扣为“人质”，直到他们完成大量与补丁无关的额外工作。虽然这些工作不一定非得在同一个提交里完成，但对你来说很重要。</p><p>“如果你还想看到你心爱的补丁……”</p><h2 id="双人组"><a href="#双人组" class="headerlink" title="双人组"></a><strong>双人组</strong></h2><p>一个补丁，两位审阅者。</p><p>每次其中一个审阅者要求修改，开发者都会顺从地做出修改——然后另一个审阅者就可以开始提出新的意见！</p><p>轮流提出互相矛盾的要求，但始终将矛头指向开发者。避免在审阅中直接与另一位审阅者争论，也不要承认补丁作者的建议，即两位审阅者应该互相沟通并达成共识，明确补丁的最终样子。</p><p>看看能让开发者在两人间来回折腾多少次，直到他们放弃。</p><p>（如果实在找不到同伙，你可以试试推翻自己之前的审阅评论。不过通常有人会发现。最好还是有两位审阅者来配合。）</p>]]></content>
    
    
    
    <tags>
      
      <tag>译文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot升级3.2报错Invalid value type for attribute factoryBeanObjectType java.lang.String的解决方案</title>
    <link href="/2024/09/28/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2024/09/28/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>这篇文章给大家介绍了SpringBoot升级3.2报错Invalid value type for attribute factoryBeanObjectType: java.lang.String的解决方案,文中有详细的原因分析,需要的朋友可以参考下</p><h1 id="错误概览"><a href="#错误概览" class="headerlink" title="错误概览"></a>错误概览</h1><p>报错截图如下：</p><p><img src="/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cerror.jpg" alt="图片引用方法三"></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p><code>mybatis-spring</code> 官方 ISSUE:<a href="https://github.com/mybatis/spring/issues/855"> https://github.com/mybatis/spring/issues/855</a></p><p>项目中使用 <code>mybatis-plus-boot-starter</code> 当前最新版本 3.5.4.1 ，其中依赖的 <code>mybatis-spring</code> 版本为 2.1.1</p><p><img src="/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cdependency.png" alt="图片引用方法三"></p><p>在 mybatis-spring 2.1.1 版本的 ClassPathMapperScanner#processBeanDefinitions 方法里将 <code>BeanClassName </code> 赋值给 String 变量</p><p><img src="/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cclue1.jpg" alt="图片引用方法三"></p><p>并将 <code>beanClassName</code> 赋值给 <code>factoryBeanObjectType</code></p><p><img src="/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cclue2.jpg" alt="图片引用方法三"></p><p>但是在 Spring Boot 3.2 版本中<code>FactoryBeanRegistrySupport#getTypeForFactoryBeanFromAttributes</code>方法已变更，如果 <code>factoryBeanObjectType</code> 不是 ResolvableType 或 Class 类型会抛出 <code>IllegalArgumentException</code> 异常。</p><p>此时因为 <code>factoryBeanObjectType</code> 是 String 类型，不符合条件而抛出异常。</p><p><img src="/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cclue3.jpg" alt="图片引用方法三"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h4 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h4><p>mybatis-spring 官方 ISSUE 说明在 3.0.3 版本修复此问题</p><p><img src="/java-lang-String%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cresolve1.png" alt="图片引用方法三"></p><p>Mybatis-Plus 官方 ISSUE#5808 下面也说明会在 3.5.5 版本升级 mybatis-spring 依赖修复此问题，但截止到目前只有快照版本 <code>3.5.5-SNAPSHOT</code> 。</p><p>所以目前好一点的方案就是手动升级 <code>mybatis-spring</code> 版本为 3.0.3</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    //排除掉mybatis-spring<br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br> //手动加上<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><p>回退到springboot 3.1.x版本，例如3.0.5.</p>]]></content>
    
    
    <categories>
      
      <category>springboot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2024/09/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="2518-好分区的数目"><a href="#2518-好分区的数目" class="headerlink" title="2518. 好分区的数目"></a><a href="https://leetcode.cn/problems/number-of-great-partitions/">2518. 好分区的数目</a></h2><p>那么原问题就转换为「从 nums 中选择若干元素，使得元素和小于 k 的方案数」，这样用 01 背包就不会超时了。</p><h2 id="3082-求出所有子序列的能量和"><a href="#3082-求出所有子序列的能量和" class="headerlink" title="3082. 求出所有子序列的能量和"></a><a href="https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/">3082. 求出所有子序列的能量和</a></h2><p>数组 nums 的长度是 n。如果数组 nums 中存在一个长度为 p 的子序列的元素和等于 k，则不在该子序列中的元素个数是 n−p，包含该长度为 p 的子序列的子序列个数是$ 2^{n-p}$，因此该长度为 p 的子序列对于数组 nums 的所有子序列的能量和的贡献值是<br>$$<br>2^{n-p}<br>$$<br>创建 (n+1)×(k+1)×(n+1) 的三维数组 dp，其中dp[i]  [j]  [k]表示数组 nums 的前 i 个元素可以组成的元素和为 j 且长度为 p 的子序列的数目。</p><p>相当于是多了一个维度 p,选择p个组成j,  而不是选择任意多个元素，多了一份约束</p><h2 id="Bone-Collector-II-（01背包的第K优解）"><a href="#Bone-Collector-II-（01背包的第K优解）" class="headerlink" title="Bone Collector II （01背包的第K优解）"></a>Bone Collector II （01背包的第K优解）</h2>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LockSupport的使用和基本原理</title>
    <link href="/2024/04/13/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/13/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1、wait和notify-x2F-notifyAll-限制"><a href="#1、wait和notify-x2F-notifyAll-限制" class="headerlink" title="1、wait和notify&#x2F;notifyAll 限制"></a>1、<strong>wait</strong>和<strong>notify</strong>&#x2F;<strong>notifyAll</strong> 限制</h2><ul><li>必须包含在 synchronized代码块里面。否则导致IllegalMonitorStateException。<br> 可以这么理解，wait是必须要释放当前线程的锁，如果一个代码块没有拿到锁，那么wait也就没有了意义。</li><li>必须先wait，再notify才可以唤醒阻塞的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">// 定义一个对象，充当锁。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待并且释放锁</span><br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(sum);<br>        &#125;<br>    &#125;);<br><br>    a.start();<br>    <span class="hljs-comment">// 睡眠一秒钟，保证A线程已经计算完成。阻塞在wait方法上，防止main线程执行太快，提前发出了notify.</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// wati,和notify 必须包含在 synchronized 代码块里面</span><br>   <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.notify();<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>错误示例1： 先notify再进行wait</strong></p><p>实际上代码就是删掉了sleep</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">// 定义一个对象，充当锁。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待并且释放锁</span><br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(sum);<br>        &#125;<br>    &#125;);<br><br>    a.start();<br>    <span class="hljs-comment">// wati,和notify 必须包含在 synchronized 代码块里面</span><br>   <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.notify();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候提前发出了通知，将导致，线程a,始终在wait,因为已经没有线程给他通知了。</p><p>为了是我们的代码看起来更加简洁，易读。jdk给我们开发LockSupport.</p><h2 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h2><p>   LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。<br>   LockSupport类使用了一种名为Permit(许可)的概念来做到阻塞和唤醒线程的功能,每个线程都有一个许可(permit),permit只有两个值1和零,默认是零</p><p>   <strong>部分源码</strong> </p><p>   里面有相当一部分的native操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    <span class="hljs-comment">// Hotspot implementation via intrinsics API</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> parkBlockerOffset;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SEED;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> PROBE;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SECONDARY;<br>    <br>    <span class="hljs-comment">//静态初始化代码块，</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取Unsafe实例</span><br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            <span class="hljs-comment">// 线程类类型</span><br>            Class&lt;?&gt; tk = Thread.class;<br>            <span class="hljs-comment">// 获取Thread的parkBlocker字段的内存偏移地址</span><br>            parkBlockerOffset = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;parkBlocker&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomSeed字段的内存偏移地址</span><br>            SEED = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSeed&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomProbe字段的内存偏移地址</span><br>            PROBE = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomProbe&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址</span><br>            SECONDARY = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSecondarySeed&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LockSupport中的方法<br><img src="https://img-blog.csdnimg.cn/direct/b347a036d85d44ba99175a57660ba7a9.png" alt="在这里插入图片描述">重点在于以下两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAbsolute, <span class="hljs-type">long</span> time)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br></code></pre></td></tr></table></figure><p>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞:<br>① 调用unpark函数，释放该线程的许可。<br>② 该线程被中断。<br>③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活</p><p>LockSupport示例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (() -&gt; &#123;<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;开始运行&quot;</span>);<br>        LockSupport.park ();<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;解除park&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;线程一&quot;</span>);<br>    <br>    t1.start ();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (() -&gt; &#123;<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;开始运行&quot;</span>);<br>        LockSupport.unpark (t1);<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;解除线程一的park&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;线程二&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">线程二开始运行<br>线程一开始运行<br>线程二解除线程一的park<br>线程一解除park<br></code></pre></td></tr></table></figure><p>注意观察，LockSupport只需要在该停止的地方park一下，不需要创建任何锁的对象，也不需要关注是否该线程拥有锁，只需要LockSupport.park().然后静静等待通知。<br>还有一点值得注意的是，我们通过观察结果发现，线程二先开始运行，意味着它先一步通知了，但是线程一没有卡住，仍然收到了通知。解除了park.<br>这就是他的优秀之处。</p>]]></content>
    
    
    <categories>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>risc-v OS学习记录</title>
    <link href="/2023/10/19/risc-vOS%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/19/risc-vOS%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>学习资料：</p><p>gdb调试   <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">linuxtools</a></p><p>make 小知识 </p><p>​1   利用-n 可以看到详细的makefile的输出</p><p>寄存器小知识</p><blockquote><p>RISC-V 架构中有一组通用寄存器（General-Purpose Registers），它们通常用于存储整数数据和执行算术操作。以下是一些常见的 RISC-V 通用寄存器及其典型的作用：</p><ol><li><strong>x0</strong>：零寄存器，总是包含值0。在某些情况下，也被称为<code>zero</code>寄存器。</li><li><strong>x1</strong>：保留寄存器，用于汇编器、链接器等工具。</li><li><strong>x2</strong> - <strong>x11</strong>：临时寄存器，通常用于存储临时数据和计算结果。</li><li><strong>x12</strong> - <strong>x17</strong>：保存寄存器（s0 - s5），通常用于保存函数调用期间的寄存器值，以便在函数返回后能够正确恢复。</li><li><strong>x18</strong> - <strong>x27</strong>：临时寄存器，类似于 x2 - x11，用于存储临时数据。</li><li><strong>x28</strong> - <strong>x31</strong>：临时寄存器，通常用于存储临时数据和计算结果。</li></ol><p>除了通用寄存器，RISC-V 架构还包括一些特殊寄存器，这些寄存器在特定的操作和功能中发挥重要作用，例如：</p><ul><li><strong>pc</strong>：程序计数器，用于存储当前指令的地址，控制程序的执行顺序。</li><li><strong>sp</strong>：栈指针，用于管理函数调用期间的堆栈。</li><li><strong>gp</strong>：全局指针，通常用于访问全局数据。</li><li><strong>tp</strong>：线程指针，用于多线程环境中跟踪线程相关的数据。</li><li><strong>fp</strong>：帧指针，用于存储函数的栈帧信息。</li><li><strong>ra</strong>：返回地址寄存器，用于存储函数返回时的返回地址。</li><li><strong>a0</strong> - <strong>a7</strong>：参数寄存器，用于传递函数参数。</li><li><strong>t0</strong> - <strong>t6</strong>：临时寄存器，类似于通用寄存器，用于存储临时数据和计算结果。</li><li><strong>sstatus</strong>：状态寄存器，用于控制和管理处理器的状态，如中断和异常处理。</li><li><strong>stvec</strong>：中断向量寄存器，指示中断处理程序的入口地址。</li><li><strong>sie</strong>：中断使能寄存器，用于允许或禁止中断的发生。</li><li><strong>sip</strong>：中断挂起寄存器，用于标记中断请求的状态。</li><li><strong>mstatus</strong>：机器模式状态寄存器，类似于 <code>sstatus</code>，但用于机器模式下。</li><li><strong>mcause</strong>：机器模式异常原因寄存器，存储最近的异常原因。</li><li><strong>mtvec</strong>：机器模式中断向量寄存器，指示异常处理程序的入口地址。</li><li><strong>mepc</strong>：机器模式程序计数器，用于保存机器模式下的程序计数器值。</li></ul><p>这些寄存器在 RISC-V 架构中的不同模式下（用户模式、机器模式等）具有不同的行为和作用，但通常用于管理程序的执行、存储数据和处理中断与异常等任务。</p></blockquote><h3 id="00-bootstrap"><a href="#00-bootstrap" class="headerlink" title="00-bootstrap"></a>00-bootstrap</h3><p>这个项目下总共有四个文件夹分别是</p><p>首先看.h文件</p><h4 id="platform-h"><a href="#platform-h" class="headerlink" title="platform.h"></a>platform.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __PLATFORM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PLATFORM_H__</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * QEMU RISC-V Virt machine with 16550a UART and VirtIO MMIO</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * maximum number of CPUs</span><br><span class="hljs-comment"> * see https://github.com/qemu/qemu/blob/master/include/hw/riscv/virt.h</span><br><span class="hljs-comment"> * #define VIRT_CPUS_MAX 8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM_CPU 8 <span class="hljs-comment">//这里的 8 应该是对应的hart的数量</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __PLATFORM_H__ */</span></span><br></code></pre></td></tr></table></figure><h4 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h4><p>注意是大写的S,可以包含#include 等指令，小写的则不行，它的作用是，在进入C语言的main函数中，初始化一些内容，比如hart的栈空间，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &quot;platform.h&quot;  //将.h文件包含<br><br># size of each hart&#x27;s stack is 1024 bytes<br>.equSTACK_SIZE, 1024 #.equ是汇编器识别的伪指令，作用是定义一个symble lable，值为1024<br><br>#定义全局的标签，是给链接器看的，告诉qemu从这里开始执行第一条指令<br>.global_start<br><br>.text<br>_start:<br># park harts with id != 0<br><br>#csrr是专门用来访问状态寄存器的<br><br>csrrt0, mhartid# read current hart id<br>mvtp, t0# keep CPU&#x27;s hartid in its tp for later usage.<br>bnezt0, park# if we&#x27;re not on the hart 0<br># we park the hart<br># Setup stacks, the stack grows from bottom to top, so we put the<br># stack pointer to the very end of the stack range.<br><br>//后面这些指令是为了不同的hart设置不同的栈空间，但是应该用不上<br>sllit0, t0, 10# shift left the hart id by 1024<br>lasp, stacks + STACK_SIZE# set the initial stack pointer<br># to the end of the first stack space<br>addsp, sp, t0# move the current hart stack pointer<br># to its place in the stack space<br><br>jstart_kernel# hart 0 jump to c<br><br>park:<br>wfi //是一种用来休眠的指令，避免空转耗电<br>jpark<br><br>stacks:<br>.skipSTACK_SIZE * MAXNUM_CPU # allocate space for all the harts stacks<br><br>.end# End of file<br><br></code></pre></td></tr></table></figure><h4 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//跳进来了以后开始空转</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;; <span class="hljs-comment">// stop here!</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>makefile 的输出</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">riscv64-unknown-elf-gcc \<br>-nostdlib \<br>-fno-builtin \<br>-march=rv32ima \ <br>-mabi=ilp32 \ <br>-g <br>-Wall <br>-c <br>-o start.o start.S<br><br></code></pre></td></tr></table></figure><blockquote><p>这是一个编译命令，用于将 RISC-V 32位体系结构的汇编文件 <code>start.S</code> 编译成目标文件 <code>start.o</code>。以下是对该命令的各个部分的解释：</p><ul><li><p><code>riscv64-unknown-elf-gcc</code>: 这是 RISC-V 交叉编译工具链（Cross-Compiler）的命令前缀。<code>riscv64-unknown-elf-gcc</code> 表示使用的是针对 RISC-V 体系结构的交叉编译器。这个编译器可用于编译 RISC-V 架构的程序。</p></li><li><p><code>-nostdlib</code>: 这是一个编译选项，指示编译器不要链接标准 C 库。通常，嵌入式系统或嵌入式应用程序可能不需要完整的标准库，因此可以使用此选项来禁用标准库的链接。</p></li><li><p><code>-fno-builtin</code>: 这也是一个编译选项，用于禁用内建函数（Builtin Functions）的使用。内建函数是编译器内置的一些函数，它们通常用于执行特定操作，如优化。使用此选项可以禁用这些内建函数。</p></li><li><p><code>-march=rv32ima</code>: 这是一个编译选项，指定了目标架构。在这里，<code>-march=rv32ima</code> 表示目标架构是 RISC-V 32位，支持整数（i）、乘法扩展（m）和原子操作扩展（a）指令集。</p></li><li><p><code>-mabi=ilp32</code>: 这是另一个编译选项，指定了目标 ABI（Application Binary Interface）。<code>ilp32</code> 表示整数类型、寄存器和地址都是32位的。这与 <code>lp64</code>（长整数类型、寄存器和地址为64位）等不同的 ABI 有关。</p></li><li><p><code>-g</code>: 这是一个编译选项，用于生成调试信息。它会在目标文件中嵌入调试信息，以便在后续调试程序时使用。</p></li><li><p><code>-Wall</code>: 这是一个编译选项，用于启用编译器的警告。编译器将生成警告消息，以帮助开发人员识别潜在的问题或错误。</p></li><li><p><code>-c</code>: 这是一个编译选项，指示编译器仅生成目标文件，而不进行链接操作。生成的目标文件通常具有 <code>.o</code> 扩展名。</p></li><li><p><code>-o start.o</code>: 这是一个编译选项，指定生成的目标文件的名称。在这里，生成的目标文件将命名为 <code>start.o</code>。</p></li></ul><p>总的来说，这个编译命令用于将 RISC-V 32位汇编文件 <code>start.S</code> 编译成目标文件 <code>start.o</code>，使用了特定的目标架构和 ABI，并启用了调试信息和警告。这是编译一个 RISC-V 32位汇编程序的标准命令。后续可以使用该目标文件进行链接操作，以创建可执行文件。</p></blockquote><h3 id="01-HelloRVOS"><a href="#01-HelloRVOS" class="headerlink" title="01-HelloRVOS"></a>01-HelloRVOS</h3><p>想办法打印出一个hello world</p>]]></content>
    
    
    <categories>
      
      <category>risc-V</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risc-v</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis的使用经验</title>
    <link href="/2023/09/30/redis%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/"/>
    <url>/2023/09/30/redis%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>Redis功能强大，数据类型丰富，再快的系统，也经不住疯狂的滥用。通过禁用部分高风险功能，并挂上开发的枷锁，业务更能够以简洁、通用的思想去考虑问题，而不是绑定在某种实现上。</p><h2 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h2><h3 id="冷热数据区分"><a href="#冷热数据区分" class="headerlink" title="冷热数据区分"></a>冷热数据区分</h3><p>虽然 Redis支持持久化，但将所有数据存储在 Redis 中，成本非常昂贵。建议将热数据 (如 QPS超过 5k) 的数据加载到 Redis 中。低频数据可存储在 Mysql、 ElasticSearch中。</p><h3 id="业务数据分离"><a href="#业务数据分离" class="headerlink" title="业务数据分离"></a>业务数据分离</h3><p>不要将不相关的数据业务都放到一个 Redis中。一方面避免业务相互影响，另一方面避免单实例膨胀，并能在故障时降低影响面，快速恢复。</p><h3 id="消息大小限制"><a href="#消息大小限制" class="headerlink" title="消息大小限制"></a>消息大小限制</h3><p>由于 Redis 是单线程服务，消息过大会阻塞并拖慢其他操作。保持消息内容在 1KB 以下是个好的习惯。严禁超过 50KB 的单条记录。消息过大还会引起网络带宽的高占用，持久化到磁盘时的 IO 问题</p><h3 id="连接数限制"><a href="#连接数限制" class="headerlink" title="连接数限制"></a>连接数限制</h3><p>连接的频繁创建和销毁，会浪费大量的系统资源，极限情况会造成宿主机宕机。请确保使用了正确的 Redis 客户端连接池配置。</p><h3 id="缓存-Key-设置失效时间"><a href="#缓存-Key-设置失效时间" class="headerlink" title="缓存 Key 设置失效时间"></a>缓存 Key 设置失效时间</h3><p>作为缓存使用的 Key，必须要设置失效时间。失效时间并不是越长越好，请根据业务性质进行设置。注意，失效时间的单位有的是秒，有的是毫秒，这个很多同学不注意容易搞错。</p><h3 id="缓存不能有中间态"><a href="#缓存不能有中间态" class="headerlink" title="缓存不能有中间态"></a>缓存不能有中间态</h3><p>缓存应该仅作缓存用，去掉后业务逻辑不应发生改变，万不可切入到业务里。</p><p>第一，缓存的高可用会影响业务；</p><p>第二，产生深耦合会发生无法预料的效果；</p><p>第三，会对维护产生负面效果。</p><h3 id="扩展方式首选客户端-hash"><a href="#扩展方式首选客户端-hash" class="headerlink" title="扩展方式首选客户端 hash"></a>扩展方式首选客户端 hash</h3><p>如单 redis 集群并不能为你的数据服务，不要着急扩大你的 redis 集群（包括 M&#x2F;S 和 Cluster)，集群越大，在状态同步和持久化方面的性能越差。优先使用客户端 hash 进行集群拆分。如：根据用户 id 分 10 个集群，用户尾号为 0 的落在第一个集群。</p><h2 id="操作限制"><a href="#操作限制" class="headerlink" title="操作限制"></a>操作限制</h2><h3 id="严禁使用-Keys"><a href="#严禁使用-Keys" class="headerlink" title="严禁使用 Keys"></a>严禁使用 Keys</h3><p>Keys 命令效率极低，属于 O(N)操作，会阻塞其他正常命令，在 cluster 上，会是灾难性的操作。严禁使用，DBA 应该 rename 此命令，从根源禁用。</p><h3 id="严禁使用-Flush"><a href="#严禁使用-Flush" class="headerlink" title="严禁使用 Flush"></a>严禁使用 Flush</h3><p>flush 命令会清空所有数据，属于高危操作。严禁使用，DBA 应该 rename 此命令，从根源禁用，仅 DBA 可操作。</p><h3 id="严禁作为消息队列使用"><a href="#严禁作为消息队列使用" class="headerlink" title="严禁作为消息队列使用"></a>严禁作为消息队列使用</h3><p>如没有非常特殊的需求，严禁将 Redis 当作消息队列使用。Redis 当作消息队列使用，会有容量、网络、效率、功能方面的多种问题。如需要消息队列，可使用高吞吐的 Kafka 或者高可靠的 RocketMQ。</p><h3 id="严禁不设置范围的批量操作"><a href="#严禁不设置范围的批量操作" class="headerlink" title="严禁不设置范围的批量操作"></a>严禁不设置范围的批量操作</h3><p>redis 那么快，慢查询除了网络延迟，就属于这些批量操作函数。大多数线上问题都是由于这些函数引起。</p><h4 id="1、-zset-严禁对-zset-的不设范围操作"><a href="#1、-zset-严禁对-zset-的不设范围操作" class="headerlink" title="1、[zset] 严禁对 zset 的不设范围操作"></a>1、[zset] 严禁对 zset 的不设范围操作</h4><p>ZRANGE、 ZRANGEBYSCORE等多个操作 ZSET 的函数，严禁使用 ZRANGE myzset 0 -1 等这种不设置范围的操作。请指定范围，如 ZRANGE myzset 0 100。如不确定长度，可使用 ZCARD 判断长度</p><h4 id="2、-hash-严禁对大数据量-Key-使用-HGETALL"><a href="#2、-hash-严禁对大数据量-Key-使用-HGETALL" class="headerlink" title="2、[hash] 严禁对大数据量 Key 使用 HGETALL"></a>2、[hash] 严禁对大数据量 Key 使用 HGETALL</h4><p>HGETALL会取出相关 HASH 的所有数据，如果数据条数过大，同样会引起阻塞，请确保业务可控。如不确定长度，可使用 HLEN 先判断长度</p><h4 id="3、-key-Redis-Cluster-集群的-mget-操作"><a href="#3、-key-Redis-Cluster-集群的-mget-操作" class="headerlink" title="3、[key] Redis Cluster 集群的 mget 操作"></a>3、[key] Redis Cluster 集群的 mget 操作</h4><p>Redis Cluster 的 MGET 操作，会到各分片取数据聚合，相比传统的 M&#x2F;S架构，性能会下降很多，请提前压测和评估</p><h4 id="4、-其他-严禁使用-sunion-sinter-sdiff等一些聚合操作"><a href="#4、-其他-严禁使用-sunion-sinter-sdiff等一些聚合操作" class="headerlink" title="4、[其他] 严禁使用 sunion, sinter, sdiff等一些聚合操作"></a>4、[其他] 严禁使用 sunion, sinter, sdiff等一些聚合操作</h4><h3 id="禁用-select-函数"><a href="#禁用-select-函数" class="headerlink" title="禁用 select 函数"></a>禁用 select 函数</h3><p>select函数用来切换 database，对于使用方来说，这是很容易发生问题的地方，cluster 模式也不支持多个 database，且没有任何收益，禁用。</p><h3 id="禁用事务"><a href="#禁用事务" class="headerlink" title="禁用事务"></a>禁用事务</h3><p>redis 本身已经很快了，如无大的必要，建议捕获异常进行回滚，不要使用事务函数，很少有人这么干。</p><h3 id="禁用-lua-脚本扩展"><a href="#禁用-lua-脚本扩展" class="headerlink" title="禁用 lua 脚本扩展"></a>禁用 lua 脚本扩展</h3><p>lua 脚本虽然能做很多看起来很 cool 的事情，但它就像是 SQL 的存储过程，会引入性能和一些难以维护的问题，禁用。</p><h3 id="禁止长时间-monitor"><a href="#禁止长时间-monitor" class="headerlink" title="禁止长时间 monitor"></a>禁止长时间 monitor</h3><p>monitor函数可以快速看到当前 redis 正在执行的数据流，但是当心，高峰期长时间阻塞在 monitor 命令上，会严重影响 redis 的性能。此命令不禁止使用，但使用一定要特别特别注意。</p><h2 id="Key-规范"><a href="#Key-规范" class="headerlink" title="Key 规范"></a>Key 规范</h2><p>Redis 的 Key 一定要规范，这样在遇到问题时，能够进行方便的定位。Redis 属于无 scheme 的 KV 数据库，所以，我们靠约定来建立其 scheme 语义。其好处：</p><p>1、能够根据某类 key 进行数据清理</p><p>2、能够根据某类 key 进行数据更新</p><p>3、能够方便了解到某类 key 的归属方和应用场景</p><p>4、为统一化、平台化做准备，减少技术变更</p><p>一般，一个 key 需要带以下维度：业务、key 用途、变量等，各个维度使用 : 进行分隔，以下是几个 key 的实例:<strong>user:sex 用户 10002232 的性别 msg:achi 201712 的用户发言数量排行榜</strong></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的锁</title>
    <link href="/2023/08/23/MySQL%E7%9A%84%E9%94%81/"/>
    <url>/2023/08/23/MySQL%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux扩容在centos-root下</title>
    <link href="/2023/03/21/linux%E6%89%A9%E5%AE%B9%E5%9C%A8centos-root%E4%B8%8B/"/>
    <url>/2023/03/21/linux%E6%89%A9%E5%AE%B9%E5%9C%A8centos-root%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<p>最近在用elasticsearch，发现索引只能读不能写，health 是red，df -h 发现磁盘空间不够了。</p><h2 id="2、在系统中挂载磁盘"><a href="#2、在系统中挂载磁盘" class="headerlink" title="2、在系统中挂载磁盘"></a>2、在系统中挂载磁盘</h2><p>开启虚拟机并登录后，使用命令查看当磁盘状态</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># df -h</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ffafd265255ffee15fb82cd6c6d8cc16.png" alt="img"></p><p>可看到当前还是原本的20G，并未扩容，首先先通过命令查看到新磁盘的分区</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># fdisk -l</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bf74ced066e8d0624b9f2f47992a3fd0.png" alt="img"></p><p>然后对新加的磁盘进行分区操作：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># fdisk <span class="hljs-regexp">/dev/</span>sda<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/63c08b0cc5808959bc6ec8bafdff62fd.png" alt="img"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7023656e1f7d907c375ba5e91f0bc611.png" alt="img"></p><p>期间，如果需要将分区类型的Linux修改为Linux LVM的话需要在新增了分区之后，选择t，然后选择8e，之后可以将新的分区修改为linux LVM，之后我们可以再次用以下命令查看到磁盘当前情况</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># fdisk -l</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/666d8d1e5200939fd74dc3e7cd524da1.png" alt="img"></p><p>重启虚拟机格式化新建分区</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># reboot</span><br></code></pre></td></tr></table></figure><p>然后将新添加的分区添加到已有的组实现扩容<br>首先查看卷组名</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># vgdisplay</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e43dbb6e32e0f575ad78b15ac4ca8b8f.png" alt="img"></p><p>初始化刚刚的分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol"># pvcreate /dev/sda3<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/063f26433d5b310418ca100d633a196d.png" alt="img"></p><p>将初始化过的分区加入到虚拟卷组名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cobol"># vgextend 虚拟卷组名 新增的分区<br><br># vgextend centos /dev/sda3<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5295809d06707d27e4bf5a343c767956.png" alt="img"></p><p>再次查看卷组情况</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># vgdisplay</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1a75a2f36580e4e9c36f5f18d2835e39.png" alt="img"></p><p>这里可以看到，有30G的空间是空闲的<br>查看当前磁盘情况并记下需要扩展的文件系统名，我这里因为要扩展根目录，所以我记下的是 &#x2F;dev&#x2F;mapper&#x2F;centos-root</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># df -h</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/218f81f60c725c804968e36af55a7857.png" alt="img"></p><p>扩容已有的卷组容量（这里有个细节，就是不能全扩展满，比如空闲空间是30G，然后这里的话30G不能全扩展上，这里我扩展的是29G）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol"><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cobol"># lvextend -L +需要扩展的容量 需要扩展的文件系统名 <br><br><br><br># lvextend -L +29G /dev/mapper/centos-root<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/24bd253c2798a02a8df60f2348d5e38d.png" alt="img"></p><p>然后我们用命令查看当前卷组</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># pvdisplay</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3176b19e8f1407898440e80163a9135a.png" alt="img"></p><p>这里可以看到，卷组已经扩容了<br>以上只是卷的扩容，然后我们需要将文件系统扩容</p><p>这个是网上很多参考资料的用法，但是在这里报错了</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/342fdd41c399bf2847b25ea0ec84056c.png" alt="img"></p><p>解决办法是，首先查看文件系统的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cobol"># cat /etc/fstab | grep centos-root<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ef8079f8913063df152bcefe4b5ef427.png" alt="img"></p><p>这里可以看到，文件系统是xfs，所以需要xfs的命令来扩展磁盘空间</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e5aeccb7003206a20a9258a0e6fa373b.png" alt="img"></p><p>之后我们再次用命令查看磁盘状态</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># df -h</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0fea8bd3aa90b12f2eb6e8434cb77900.png" alt="img"></p><p>扩容成功！</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>lombok 的注解</title>
    <link href="/2022/09/30/lombok%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/09/30/lombok%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Getter-和-Setter"><a href="#1-Getter-和-Setter" class="headerlink" title="1. @Getter 和 @Setter"></a>1. <code>@Getter</code> 和 <code>@Setter</code></h3><ul><li><p><strong>功能</strong>：自动生成类中的所有字段的 getter 和 setter 方法。</p></li><li><p><strong>用法</strong>：</p><ul><li><code>@Getter</code>：为字段生成 <code>getter</code> 方法。</li><li><code>@Setter</code>：为字段生成 <code>setter</code> 方法。</li></ul><p><strong>示例</strong>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">javaimport</span> <span class="hljs-selector-tag">lombok</span><span class="hljs-selector-class">.Getter</span>;<br><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">lombok</span><span class="hljs-selector-class">.Setter</span>;<br><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">User</span> &#123;<br>    <span class="hljs-variable">@Getter</span> <span class="hljs-variable">@Setter</span><br>    private String name;<br><br>    <span class="hljs-variable">@Getter</span> <span class="hljs-variable">@Setter</span><br>    private int age;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-NoArgsConstructor、-AllArgsConstructor、-RequiredArgsConstructor"><a href="#3-NoArgsConstructor、-AllArgsConstructor、-RequiredArgsConstructor" class="headerlink" title="3. @NoArgsConstructor、@AllArgsConstructor、@RequiredArgsConstructor"></a>3. <code>@NoArgsConstructor</code>、<code>@AllArgsConstructor</code>、<code>@RequiredArgsConstructor</code></h3><ul><li><p><strong>功能</strong>：</p><ul><li><code>@NoArgsConstructor</code>：生成一个无参构造器。</li><li><code>@AllArgsConstructor</code>：生成一个全参构造器（包含类中所有字段的构造函数）。</li><li><code>@RequiredArgsConstructor</code>：生成一个包含 <code>final</code> 或带 <code>@NonNull</code> 注解字段的构造函数。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">javaimport lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.NonNull;<br><br><span class="hljs-meta">@NoArgsConstructor</span> <span class="hljs-comment">// 无参构造器</span><br><span class="hljs-meta">@AllArgsConstructor</span> <span class="hljs-comment">// 全参构造器</span><br><span class="hljs-meta">@RequiredArgsConstructor</span> <span class="hljs-comment">// 只包含final和@NonNull字段的构造器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">private</span> Integer age; <span class="hljs-comment">// 由于带@NonNull，会被RequiredArgsConstructor包含</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Data"><a href="#2-Data" class="headerlink" title="2. @Data"></a>2. <code>@Data</code></h3><ul><li><p><strong>功能</strong>：自动生成 <code>getter</code>、<code>setter</code>、<code>toString()</code>、<code>equals()</code>、<code>hashCode()</code> 和 <code>全参构造器</code>。</p></li><li><p><strong>用法</strong>：</p><p><strong>示例</strong>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fortran">javaimport lombok.<span class="hljs-keyword">Data</span>;<br><br>@<span class="hljs-keyword">Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> User &#123;<br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">name</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个注解等效于同时使用 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code> 和 <code>@RequiredArgsConstructor</code>。你可以快速生成一整个实体类的基础功能。</p></li></ul><h3 id="6-Builder"><a href="#6-Builder" class="headerlink" title="6. @Builder"></a>6. <code>@Builder</code></h3><ul><li><p><strong>功能</strong>：为类生成一个 <code>Builder</code> 模式的构造器，方便链式构造对象。</p></li><li><p><strong>用法</strong>：</p><p><strong>示例</strong>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">javaimport lombok.Builder;<br><br>@Builder<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用生成的 <code>builder</code>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">java<br><span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-keyword">User</span>.builder().name(&quot;Alice&quot;).age(<span class="hljs-number">25</span>).build();<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-NonNull"><a href="#7-NonNull" class="headerlink" title="7. @NonNull"></a>7. <code>@NonNull</code></h3><ul><li><p><strong>功能</strong>：为字段生成空值检查。如果构造器或方法参数使用了 <code>@NonNull</code>，Lombok 会自动在生成的代码中插入空值检查。</p></li><li><p><strong>用法</strong>：</p><p><strong>示例</strong>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">javaimport lombok.NonNull;<br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span>(@NonNull String <span class="hljs-type">name</span>) &#123;<br>        this.name = <span class="hljs-type">name</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这会在构造器中生成类似于以下的代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">javapublic <span class="hljs-keyword">User</span>(String <span class="hljs-type">name</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">name</span> == <span class="hljs-keyword">null</span>) &#123;<br>        throw <span class="hljs-built_in">new</span> NullPointerException(&quot;name is marked @NonNull but is null&quot;);<br>    &#125;<br>    this.name = <span class="hljs-type">name</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="8-Synchronized"><a href="#8-Synchronized" class="headerlink" title="8. @Synchronized"></a>8. <code>@Synchronized</code></h3><ul><li><p><strong>功能</strong>：生成同步方法（类似于 <code>synchronized</code> 关键字）。比直接在方法上使用 <code>synchronized</code> 更安全，因为它可以防止同步在 <code>null</code> 对象上。</p></li><li><p><strong>用法</strong>：</p><p><strong>示例</strong>：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">javaimport lombok.<span class="hljs-keyword">Synchronized</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Counter &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    @<span class="hljs-keyword">Synchronized</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> increment() &#123;<br>        <span class="hljs-keyword">count</span>++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="9-Slf4j"><a href="#9-Slf4j" class="headerlink" title="9. @Slf4j"></a>9. <code>@Slf4j</code></h3><ul><li><p><strong>功能</strong>：为类生成一个 <code>Slf4j</code> 日志记录器实例。</p></li><li><p><strong>用法</strong>：</p><p><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">javaimport lombok.<span class="hljs-keyword">extern</span>.slf4j.Slf4j;<br><br>@Slf4j<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span>()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Processing user...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个注解会自动为类生成 <code>log</code> 对象，用于日志记录。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>lombok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sql窗口函数</title>
    <link href="/2022/09/28/Sql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2022/09/28/Sql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数语法"><a href="#窗口函数语法" class="headerlink" title="窗口函数语法"></a>窗口函数语法</h2><p>SQL窗口函数是SQL中的一种高级函数，它允许用户在不显式分组查询的情况下对结果集进行分组和聚合计算。<br> 窗口函数的特别之处在于，它们将结果集中的每一行看作一个单独的计算对象，而不是将结果集划分为分组并计算每个分组的聚合值。这就使得窗口函数能够为结果集中的每一行计算类似排名、行号、百分比和移动聚合函数等值。</p><p><strong>SQL窗口函数的语法如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-operator">&lt;</span>窗口函数<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">OVER</span> ([<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>分组列<span class="hljs-operator">&gt;</span> [, <span class="hljs-operator">&lt;</span>分组列<span class="hljs-operator">&gt;</span>...]]<br><br>                     [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>排序列<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>] [, <span class="hljs-operator">&lt;</span>排序列<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]]...]<br><br>                     [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">rows</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">range</span> clause<span class="hljs-operator">&gt;</span>])<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>&lt;窗口函数&gt;</code> : 定义要在窗口中计算的聚合函数或其它分析函数，如COUNT、RANK、SUM等。</li><li><code>OVER</code> : 窗口函数的核心关键字。</li><li><code>PARTITION BY</code> : 定义要用来分组的一组列名。</li><li><code>ORDER BY</code> : 定义用来排序的一组列名。</li><li><code>&lt;rows or range clause&gt;</code> : 定义窗口的行集合。默认为  <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code> ，表示窗口包括从窗口开始到当前行的所有行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemctl命令介绍和使用</title>
    <link href="/2020/09/28/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/28/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Systemd程序"><a href="#Systemd程序" class="headerlink" title="Systemd程序"></a>Systemd程序</h3><p>Systemd其实是Linux系统用来管理系统的一个程序，用来代替原来的init进程(用来管理启动系统其它的服务进程)，现在很多Linux发行版都已经自带Systemd程序了。</p><h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><h4 id="1-Unit"><a href="#1-Unit" class="headerlink" title="1. Unit"></a>1. Unit</h4><p>systemctl命令是Systemd中最重要的一个命令，用于对服务进行启动，停止等操作，在Systemd中有Unit的概念，每个进程都是一个Unit，总共有十二种Unit类型。</p><ul><li>Service unit，系统服务</li><li>Target unit，多个 Unit 构成的一个组</li><li>Device Unit，硬件设备</li><li>Mount Unit，文件系统的挂载点</li><li>Automount Unit，自动挂载点</li><li>Path Unit，文件或路径</li><li>Scope Unit，不是由 Systemd 启动的外部进程</li><li>Slice Unit，进程组</li><li>Snapshot Unit，Systemd 快照，可以切回某个快照</li><li>Socket Unit，进程间通信的 socket</li><li>Swap Unit，swap 文件</li><li>Timer Unit，定时器</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 列出正在运行的Unit<br>systemctl list<span class="hljs-operator">-</span>units，可以直接使用systemctl<br><br># 列出所有Unit，包括没有找到配置文件的或者启动失败的<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--all</span><br><br># 列出所有没有运行的 Unit<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--all --state=inactive</span><br><br># 列出所有加载失败的 Unit<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--failed</span><br><br># 列出所有正在运行的、类型为service的Unit<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--type=service</span><br><br># 显示某个 Unit 是否正在运行<br>systemctl <span class="hljs-keyword">is</span><span class="hljs-operator">-</span>active application.service<br><br># 显示某个 Unit 是否处于启动失败状态<br>systemctl <span class="hljs-keyword">is</span><span class="hljs-operator">-</span>failed application.service<br><br># 显示某个 Unit 服务是否建立了启动链接<br>systemctl <span class="hljs-keyword">is</span><span class="hljs-operator">-</span>enabled application.service<br><br># 立即启动一个服务<br>sudo systemctl <span class="hljs-keyword">start</span> apache.service<br><br># 立即停止一个服务<br>sudo systemctl stop apache.service<br><br># 重启一个服务<br>sudo systemctl restart apache.service<br><br># 重新加载一个服务的配置文件<br>sudo systemctl reload apache.service<br><br># 重载所有修改过的配置文件<br>sudo systemctl daemon<span class="hljs-operator">-</span>reload<br></code></pre></td></tr></table></figure><h3 id="systemctl中Unit的配置文件"><a href="#systemctl中Unit的配置文件" class="headerlink" title="systemctl中Unit的配置文件"></a>systemctl中Unit的配置文件</h3><p>上面说了每个服务都是一个Unit，那每个Unit都会有它的配置文件，这样启动的时候才知道要按照什么方式去启动。Systemd默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。</p><h4 id="1-查看Unit的配置文件"><a href="#1-查看Unit的配置文件" class="headerlink" title="1. 查看Unit的配置文件"></a>1. 查看Unit的配置文件</h4><p>可以使用<code>systemctl cat</code>命令来查看服务的配置文件，下面是Mysql的配置文件，很多软件已经支持Systemd程序了，安装的时候会自动配置它的Unit配置文件，例如Mysql和Nginx等等。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[root@VM_0_11_centos ~]</span><span class="hljs-comment"># systemctl cat mysqld</span><br><span class="hljs-comment"># /usr/lib/systemd/system/mysqld.service</span><br><br><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=MySQL Server<br><span class="hljs-attr">Documentation</span>=man:mysqld(<span class="hljs-number">8</span>)<br><span class="hljs-attr">Documentation</span>=http://dev.mysql.com/doc/refman/en/using-systemd.html<br><span class="hljs-attr">After</span>=network.target<br><span class="hljs-attr">After</span>=syslog.target<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">User</span>=mysql<br><span class="hljs-attr">Group</span>=mysql<br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">PIDFile</span>=/var/run/mysqld/mysqld.pid<br><span class="hljs-comment"># Disable service start and stop timeout logic of systemd for mysqld service.</span><br><span class="hljs-attr">TimeoutSec</span>=<span class="hljs-number">0</span><br><span class="hljs-comment"># Execute pre and post scripts as root</span><br><span class="hljs-attr">PermissionsStartOnly</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment"># Needed to create system tables</span><br><span class="hljs-attr">ExecStartPre</span>=/usr/bin/mysqld_pre_systemd<br><span class="hljs-comment"># Start main service</span><br><span class="hljs-attr">ExecStart</span>=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid <span class="hljs-variable">$MYSQLD_OPTS</span><br><span class="hljs-comment"># Use this to switch malloc implementation</span><br><span class="hljs-attr">EnvironmentFile</span>=-/etc/sysconfig/mysql<br><span class="hljs-comment"># Sets open_files_limit</span><br><span class="hljs-attr">LimitNOFILE</span> = <span class="hljs-number">5000</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartPreventExitStatus</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h4 id="2-Unit配置文件的含义"><a href="#2-Unit配置文件的含义" class="headerlink" title="2. Unit配置文件的含义"></a>2. Unit配置文件的含义</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以看到Unit配置文件有很多标签，不同的标签都代表了不同的意思，这里只列出部分介绍，可以去官网查看Unit配置文件文档介绍，https://www.freedesktop.org/software/systemd/man/systemd.unit.html。<br><br><span class="hljs-bullet">-</span> Unit<br><span class="hljs-bullet">   -</span> Description，服务的描述<br><span class="hljs-bullet">   -</span> Documentation，文档介绍<br><span class="hljs-bullet">   -</span> After，该服务要在什么服务启动之后启动，比如Mysql需要在network和syslog启动之后再启动<br><span class="hljs-bullet">-</span> Install<br><span class="hljs-bullet">   -</span> WantedBy，值是一个或多个Target，当前Unit激活时(enable)符号链接会放入/etc/systemd/system目录下面以Target名+.wants后缀构成的子目录中<br><span class="hljs-bullet">   -</span> RequiredBy，它的值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.required后缀构成的子目录中<br><span class="hljs-bullet">   -</span> Alias，当前Unit可用于启动的别名<br><span class="hljs-bullet">   -</span> Also，当前Unit激活(enable)时，会被同时激活的其他Unit<br><span class="hljs-bullet">-</span> Service<br><span class="hljs-bullet">   -</span> Type，定义启动时的进程行为。它有以下几种值。<br><span class="hljs-bullet">   -</span> Type=simple，默认值，执行ExecStart指定的命令，启动主进程<br><span class="hljs-bullet">   -</span> Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出<br><span class="hljs-bullet">   -</span> Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行<br><span class="hljs-bullet">   -</span> Type=dbus，当前服务通过D-Bus启动<br><span class="hljs-bullet">   -</span> Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行<br><span class="hljs-bullet">   -</span> Type=idle，若有其他任务执行完毕，当前服务才会运行<br><span class="hljs-bullet">   -</span> ExecStart，启动当前服务的命令<br><span class="hljs-bullet">   -</span> ExecStartPre，启动当前服务之前执行的命令<br><span class="hljs-bullet">   -</span> ExecStartPost，启动当前服务之后执行的命令<br><span class="hljs-bullet">   -</span> ExecReload，重启当前服务时执行的命令<br><span class="hljs-bullet">   -</span> ExecStop，停止当前服务时执行的命令<br><span class="hljs-bullet">   -</span> ExecStopPost，停止当其服务之后执行的命令<br><span class="hljs-bullet">   -</span> RestartSec，自动重启当前服务间隔的秒数<br><span class="hljs-bullet">   -</span> Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog<br><span class="hljs-bullet">   -</span> TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数<br><span class="hljs-bullet">   -</span> Environment，指定环境变量<br></code></pre></td></tr></table></figure><h3 id="自定义服务启动"><a href="#自定义服务启动" class="headerlink" title="自定义服务启动"></a>自定义服务启动</h3><p>既然Systemd的作用就是控制服务的启动，那么就可以把自己的服务添加进去，就可以直接使用systemctl命令来控制服务的启动，或者是设置开机自动启动等等。</p><p>在<code>/usr/lib/systemd/system</code>目录中创建自己的配置文件，一般都是<code>.service</code>结尾，例如这里创建了一个<code>test-sh.service</code>配置文件，这个Unit是为了启动我们自己的一个shell脚本。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># /usr/lib/systemd/system/test-sh.service</span><br><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>= test sh log<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">ExecStart</span>=/opt/dev/shell/test.sh<br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">KillMode</span>=process<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">30</span>s<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br></code></pre></td></tr></table></figure><h4 id="2-创建脚本"><a href="#2-创建脚本" class="headerlink" title="2. 创建脚本"></a>2. 创建脚本</h4><p>在上面配置文件指定的启动路径<code>/opt/dev/shell/</code>下创建shell脚本，这里只是每秒打印当前时间，并输出到一个文本中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">sleep</span> 1<br> <span class="hljs-built_in">date</span>=`<span class="hljs-built_in">date</span> -d today +<span class="hljs-string">&quot;%Y-%m-%d %T&quot;</span>`<br> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;date&#125;</span> &gt;&gt; /opt/dev/shell/test.txt<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="3-载入配置文件并启动"><a href="#3-载入配置文件并启动" class="headerlink" title="3. 载入配置文件并启动"></a>3. 载入配置文件并启动</h4><p>使用<code>systemctl daemon-reload</code>命令来载入新添加的配置文件，然后使用<code>systemctl start test-sh.service</code>命令启动，再使用<code>systemctl status test-sh.service</code>命令来查看状态，可以看到已经启动，<code>/opt/dev/shell/test.txt</code>也确实在不停的写入内容，最后使用<code>systemctl stop test-sh.service</code>命令停止服务，可以看到状态也是停止了。</p><p>注意的是修改配置文件后一定要使用<code>systemctl daemon-reload</code>命令来载入新添加的配置文件，然后再启动服务。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl start test-sh.service</span><br>^C<br>[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl status test-sh.service</span><br>● test-sh.service - test sh log<br>   Loaded: loaded (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/test-sh.service; enabled; vendor preset: disabled)<br>   Active: activating (start) since Fri <span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">46</span>:<span class="hljs-number">45</span> CST; <span class="hljs-number">11</span>s ago<br>   Control: <span class="hljs-number">9295</span> (test.sh)<br>   CGroup: <span class="hljs-regexp">/system.slice/</span>test-sh.service<br>       ├─<span class="hljs-number">9295</span> <span class="hljs-regexp">/bin/</span>bash <span class="hljs-regexp">/opt/</span>dev<span class="hljs-regexp">/shell/</span>test.sh<br>       └─<span class="hljs-number">9343</span> sleep <span class="hljs-number">1</span><br><br>Jun <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">46</span>:<span class="hljs-number">45</span> VM_0_11_centos systemd[<span class="hljs-number">1</span>]: Starting test sh log...<br>[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl stop test-sh.service</span><br>[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl status test-sh.service</span><br>● test-sh.service - test sh log<br>   Loaded: loaded (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/test-sh.service; enabled; vendor preset: disabled)<br>   Active: inactive (dead) since Fri <span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52</span> CST; <span class="hljs-number">2</span>s ago<br>  Process: <span class="hljs-number">9295</span> ExecStart=<span class="hljs-regexp">/opt/</span>dev<span class="hljs-regexp">/shell/</span>test.sh (code=killed, signal=TERM)<br><br>Jun <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">46</span>:<span class="hljs-number">45</span> VM_0_11_centos systemd[<span class="hljs-number">1</span>]: Starting test sh log...<br>Jun <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52</span> VM_0_11_centos systemd[<span class="hljs-number">1</span>]: Stopped test sh log.<br></code></pre></td></tr></table></figure><h3 id="查看Unit启动日志"><a href="#查看Unit启动日志" class="headerlink" title="查看Unit启动日志"></a>查看Unit启动日志</h3><p>Systemd统一管理了所有Unit的启动日志，因此只需要使用journalctl命令就可以查看到服务的日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看所有日志（默认情况下 ，只保存本次启动的日志）<br>journalctl<br><br># 查看指定时间的日志<br>journalctl <span class="hljs-comment">--since=&quot;2012-10-30 18:17:16&quot;</span><br>journalctl <span class="hljs-comment">--since &quot;20 min ago&quot;</span><br>journalctl <span class="hljs-comment">--since yesterday</span><br>journalctl <span class="hljs-comment">--since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br>journalctl <span class="hljs-comment">--since 09:00 --until &quot;1 hour ago&quot;</span><br><br># 显示尾部的最新<span class="hljs-number">10</span>行日志<br>journalctl <span class="hljs-operator">-</span>n<br><br># 显示尾部指定行数的日志<br>journalctl <span class="hljs-operator">-</span>n <span class="hljs-number">20</span><br><br># 实时滚动显示最新日志<br>journalctl <span class="hljs-operator">-</span>f<br><br># 查看指定服务的日志<br>journalctl <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>systemd<span class="hljs-operator">/</span>systemd<br><br># 查看指定进程的日志<br>journalctl _PID<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br># 查看某个路径的脚本的日志<br>journalctl <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>bash<br><br># 查看指定用户的日志<br>journalctl _UID<span class="hljs-operator">=</span><span class="hljs-number">33</span> <span class="hljs-comment">--since today</span><br><br># 查看某个 Unit 的日志<br>journalctl <span class="hljs-operator">-</span>u nginx.service<br>journalctl <span class="hljs-operator">-</span>u nginx.service <span class="hljs-comment">--since today</span><br><br># 实时滚动显示某个 Unit 的最新日志<br>journalctl <span class="hljs-operator">-</span>u nginx.service <span class="hljs-operator">-</span>f<br><br># 合并显示多个 Unit 的日志<br>$ journalctl <span class="hljs-operator">-</span>u nginx.service <span class="hljs-operator">-</span>u php<span class="hljs-operator">-</span>fpm.service <span class="hljs-comment">--since today</span><br></code></pre></td></tr></table></figure><blockquote><p>一天的光阴，能够写进我们记忆中的并不多，能够为人生带来些助益的，也不见得有多少。我们一直在求有所得，但却每一分每一秒都在错过。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输出的网络连接信息含义</title>
    <link href="/2020/09/27/%E8%BE%93%E5%87%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF%E5%90%AB%E4%B9%89/"/>
    <url>/2020/09/27/%E8%BE%93%E5%87%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一、ifconfig-与-ip-addr"><a href="#一、ifconfig-与-ip-addr" class="headerlink" title="一、ifconfig 与 ip addr"></a>一、ifconfig 与 ip addr</h3><p>用过Linux的读者都知道，在Linux查看ip可以使用ifconfig，当然这个ifconfig属于<code>net-tools</code> 工具集，其来源于BSD，Linux从2001年就不对其进行维护了。那我们应该用什么呢？还有<code>iproute2</code> 工具集，其功能更强大，我们今天就来讲讲该工具集的<code>ip addr</code>命令。</p><p>而运行ip addr命令，会出现类似下面的的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>: lo: <span class="hljs-operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="hljs-operator">&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue state <span class="hljs-literal">UNKNOWN</span> qlen <span class="hljs-number">1</span><br>    link<span class="hljs-operator">/</span>loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    inet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-operator">/</span><span class="hljs-number">8</span> <span class="hljs-keyword">scope</span> host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">128</span> <span class="hljs-keyword">scope</span> host<br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">2</span>: ens33: <span class="hljs-operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="hljs-operator">&gt;</span> mtu <span class="hljs-number">1500</span> qdisc pfifo_fast state UP qlen <span class="hljs-number">1000</span><br>    link<span class="hljs-operator">/</span>ether <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:<span class="hljs-number">62</span>:<span class="hljs-number">3</span>c:<span class="hljs-number">62</span>:a1 brd ff:ff:ff:ff:ff:ff<br>    inet <span class="hljs-number">192.168</span><span class="hljs-number">.108</span><span class="hljs-number">.19</span><span class="hljs-operator">/</span><span class="hljs-number">24</span> brd <span class="hljs-number">192.168</span><span class="hljs-number">.108</span><span class="hljs-number">.255</span> <span class="hljs-keyword">scope</span> <span class="hljs-keyword">global</span> ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::<span class="hljs-number">5</span>df:<span class="hljs-number">3</span>b5f:e5fe:ddc2<span class="hljs-operator">/</span><span class="hljs-number">64</span> <span class="hljs-keyword">scope</span> link<br>       valid_lft forever preferred_lft forever<br><br></code></pre></td></tr></table></figure><h4 id="二、IP地址"><a href="#二、IP地址" class="headerlink" title="二、IP地址"></a>二、IP地址</h4><h5 id="1）网络地址"><a href="#1）网络地址" class="headerlink" title="1）网络地址"></a>1）网络地址</h5><p>IP地址由网络号（包括子网号）+主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><h5 id="2）广播地址"><a href="#2）广播地址" class="headerlink" title="2）广播地址"></a>2）广播地址</h5><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p>255.255.255.255：该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。</p><h5 id="3）组播地址"><a href="#3）组播地址" class="headerlink" title="3）组播地址"></a>3）组播地址</h5><p>D类地址就是组播地址。</p><blockquote><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0<del>127.255.255.255；<br>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0</del>191.255.255.255;<br>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0<del>223.255.255.255。<br>D类地址以1110开头，地址范围是224.0.0.0</del>239.255.255.255，D类地址作为组播地址（一对多的通信）；<br>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p></blockquote><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><h5 id="4）0-0-0-0"><a href="#4）0-0-0-0" class="headerlink" title="4）0.0.0.0"></a>4）0.0.0.0</h5><p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><h5 id="5）回环地址"><a href="#5）回环地址" class="headerlink" title="5）回环地址"></a>5）回环地址</h5><p>127.0.0.0&#x2F;8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><h5 id="6）A、B、C类私有地址"><a href="#6）A、B、C类私有地址" class="headerlink" title="6）A、B、C类私有地址"></a>6）A、B、C类私有地址</h5><blockquote><p> 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p></blockquote><blockquote><p>A类私有地址：10.0.0.0&#x2F;8，范围是：10.0.0.0~10.255.255.255</p></blockquote><blockquote><p>B类私有地址：172.16.0.0&#x2F;12，范围是：172.16.0.0~172.31.255.255</p></blockquote><blockquote><p>C类私有地址：192.168.0.0&#x2F;16，范围是：192.168.0.0~192.168.255.255</p></blockquote><p>了解以上内容之后，再看其中的<code>192.168.108.19/24</code>便是<code>IPv4</code>的地址，这个地址由4个部分组成，每个部分8个bit，<strong>因此整个地址空间有 4 294 967 296（232232）个地址，也就是近43亿个地址。</strong> 地球上的人口都比这个多，何况我们很多人都不止使用一个IP地址吧？何况<strong>还有一些地址是作为特殊用途而保留的，如局域网专用地址（约1800万个地址）和组播地址（约2700万个地址）</strong> 。这样IPv4能够使用的地址就更少了，所有我们有了IPv6，IPv6有128位，其地址空间有340282366920938463463374607431768211456个地址，我觉得暂时是够了。128位有点长，于是采用16进制来描述IPv6地址，所有看起来IPv6的地址只有32位。</p><p>那么IPv4后面斜杠&#x2F;以及后面的数字代表什么意思呢？这就和CIDR又关系了，<code>192.168.108.19/24</code>说明前24位是网络号，后8位是主机号。通过这种方式，它根据用户的要求根据某些规则动态分配IP地址。</p><p>还有一种叫做子网掩码的东西，将子网掩码与IP地址做与运算，就能得到网络号。</p><p><strong>CIDR使IP地址从三级编址(使用子网掩码)，又回到了两级编址，但这已是无分类的两级编址。</strong></p><h4 id="三、MAC地址"><a href="#三、MAC地址" class="headerlink" title="三、MAC地址"></a>三、MAC地址</h4><p>在命令输出结果中<code>link/ether 00:0c:62:3c:62:a1 brd ff:ff:ff:ff:ff:ff</code>代表MAC地址，是网卡的物理地址，这个MAC地址是网卡出厂就确定了的，具有唯一性。</p><p>但是具有唯一性，不代表我们就干脆用它来进行通信，可以这样类比：MAC地址是我们的身份证号，而IP地址是我们身份证上的地址。</p><p>你要找一个远方的朋友进行联系，你用这个身份证号去问别人，是不是没人知道，而用家庭地址一步一步去找，是不是肯定能找到。</p><p>那么MAC地址是不是就没用了呢，不是！其具有通信作用，你想想，你去问朋友的家人，这个身份证号是谁，他是不是能够知道。MAC地址的通信范围只能在一个子网中，只要跨子网，MAC地址就没有作用了。</p><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><h5 id="4-1-scope"><a href="#4-1-scope" class="headerlink" title="4.1 scope"></a>4.1 scope</h5><p><code>inet 192.168.108.19/24 brd 192.168.108.255 scope global ens33</code>这里面scope代表作用范围，ens33这张网卡这里查询是global，说明可以接受全局的包，哪里的包都接受。而lo网卡查询的scope是host，说明该网卡只能在本机通信。</p><h5 id="4-2-lo"><a href="#4-2-lo" class="headerlink" title="4.2 lo"></a>4.2 lo</h5><p>lo代表<strong>loopback</strong>，是虚拟接口，是一种纯软件性质的虚拟接口。任何送到该接口的网络数据报文都会被认为是送往设备自身的。</p><h5 id="4-3-lt-BROADCAST-MULTICAST-UP-LOWER-UP-gt"><a href="#4-3-lt-BROADCAST-MULTICAST-UP-LOWER-UP-gt" class="headerlink" title="4.3  &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;"></a>4.3  &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="hljs-operator">&gt;</span> mtu <span class="hljs-number">1500</span> qdisc pfifo_fast state UP qlen <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p><code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code>这个东西是<strong>net_device flags</strong>，<strong>网络设备的状态标识</strong>。</p><blockquote><p>BROADCAST   该接口支持广播</p><p>MULTICAST   该接口支持多播</p><p>UP          网络接口已启用</p><p>LOWER_UP    网络电缆已插入，设备已连接至网络</p></blockquote><h5 id="4-4-MTU"><a href="#4-4-MTU" class="headerlink" title="4.4 MTU"></a>4.4 MTU</h5><p>至于<code>mtu 1500</code>是指最大传输单元MTU（Maximum Transmission Unit，MTU），表示网络可以传输的最大数据包大小，以字节为单位。</p><p>MTU的大小决定了发送端一次能够发送报文的最大字节数。如果MTU超过了接收端所能够承受的最大值，或者是超过了发送路径上途经的某台设备所能够承受的最大值，就会造成报文分片甚至丢弃，加重网络传输的负担。如果太小，那实际传送的数据量就会过小，影响传输效率。</p><h5 id="4-5-QDisk"><a href="#4-5-QDisk" class="headerlink" title="4.5 QDisk"></a>4.5 QDisk</h5><p><code>qdisc pfifo_fast</code>中，QDisk是queueing discipline的简写，即排队规则。</p><p>这篇文章对排队规则介绍得非常好：[<a href="https://link.juejin.cn/?target=http://arthurchiao.art/blog/lartc-qdisc-zh/%2391-%E9%98%9F%E5%88%97queues%E5%92%8C%E6%8E%92%E9%98%9F%E8%A7%84%E5%88%99queueing-disciplines">译] 《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽 (arthurchiao.art)</a></p><h5 id="4-6-statu"><a href="#4-6-statu" class="headerlink" title="4.6 statu"></a>4.6 statu</h5><p><code>state UP</code>表示网络接口已启用。</p><h5 id="4-7-Qlen"><a href="#4-7-Qlen" class="headerlink" title="4.7 Qlen"></a>4.7 Qlen</h5><p><code>qlen 1000</code>，Qlen代表传输队列长度，此处为1000。</p><h5 id="4-8-valid-lft-amp-preferred-lft"><a href="#4-8-valid-lft-amp-preferred-lft" class="headerlink" title="4.8 valid_lft &amp; preferred_lft"></a>4.8 valid_lft &amp; preferred_lft</h5><p>valid_lft forever IPv4&#x2F;IPv6 地址的有效使用期限</p><p>preferred_lft forever IPv4&#x2F;IPv6 地址的首选生存期</p><blockquote><p>一天的光阴，能够写进我们记忆中的并不多，能够为人生带来些助益的，也不见得有多少。我们一直在求有所得，但却每一分每一秒都在错过。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ip</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
