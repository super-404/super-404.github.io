<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2024/09/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/number-of-great-partitions/">2518. 好分区的数目</a></p><p>那么原问题就转换为「从 nums 中选择若干元素，使得元素和小于 k 的方案数」，这样用 01 背包就不会超时了。</p><p><a href="https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/">3082. 求出所有子序列的能量和</a></p><p>数组 nums 的长度是 n。如果数组 nums 中存在一个长度为 p 的子序列的元素和等于 k，则不在该子序列中的元素个数是 n−p，包含该长度为 p 的子序列的子序列个数是$ 2^{n-p}$，因此该长度为 p 的子序列对于数组 nums 的所有子序列的能量和的贡献值是<br>$$<br>2^{n-p}<br>$$<br>创建 (n+1)×(k+1)×(n+1) 的三维数组 dp，其中dp[i]  [j]  [k]表示数组 nums 的前 i 个元素可以组成的元素和为 j 且长度为 p 的子序列的数目。</p><p>相当于是多了一个维度 p,选择p个组成j,  而不是选择任意多个元素，多了一份约束</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LockSupport的使用和基本原理</title>
    <link href="/2024/04/13/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/13/LockSupport%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1、wait和notify-x2F-notifyAll-限制"><a href="#1、wait和notify-x2F-notifyAll-限制" class="headerlink" title="1、wait和notify&#x2F;notifyAll 限制"></a>1、<strong>wait</strong>和<strong>notify</strong>&#x2F;<strong>notifyAll</strong> 限制</h2><ul><li>必须包含在 synchronized代码块里面。否则导致IllegalMonitorStateException。<br> 可以这么理解，wait是必须要释放当前线程的锁，如果一个代码块没有拿到锁，那么wait也就没有了意义。</li><li>必须先wait，再notify才可以唤醒阻塞的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">// 定义一个对象，充当锁。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待并且释放锁</span><br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(sum);<br>        &#125;<br>    &#125;);<br><br>    a.start();<br>    <span class="hljs-comment">// 睡眠一秒钟，保证A线程已经计算完成。阻塞在wait方法上，防止main线程执行太快，提前发出了notify.</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// wati,和notify 必须包含在 synchronized 代码块里面</span><br>   <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.notify();<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>错误示例1： 先notify再进行wait</strong></p><p>实际上代码就是删掉了sleep</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    <span class="hljs-comment">// 定义一个对象，充当锁。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">10</span> ;i ++) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//等待并且释放锁</span><br>                obj.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(sum);<br>        &#125;<br>    &#125;);<br><br>    a.start();<br>    <span class="hljs-comment">// wati,和notify 必须包含在 synchronized 代码块里面</span><br>   <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>       obj.notify();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候提前发出了通知，将导致，线程a,始终在wait,因为已经没有线程给他通知了。</p><p>为了是我们的代码看起来更加简洁，易读。jdk给我们开发LockSupport.</p><h2 id="LockSupport简介"><a href="#LockSupport简介" class="headerlink" title="LockSupport简介"></a>LockSupport简介</h2><p>   LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。<br>   LockSupport类使用了一种名为Permit(许可)的概念来做到阻塞和唤醒线程的功能,每个线程都有一个许可(permit),permit只有两个值1和零,默认是零</p><p>   <strong>部分源码</strong> </p><p>   里面有相当一部分的native操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br>    <span class="hljs-comment">// Hotspot implementation via intrinsics API</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> sun.misc.Unsafe UNSAFE;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> parkBlockerOffset;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SEED;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> PROBE;<br>    <span class="hljs-comment">// 表示内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> SECONDARY;<br>    <br>    <span class="hljs-comment">//静态初始化代码块，</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取Unsafe实例</span><br>            UNSAFE = sun.misc.Unsafe.getUnsafe();<br>            <span class="hljs-comment">// 线程类类型</span><br>            Class&lt;?&gt; tk = Thread.class;<br>            <span class="hljs-comment">// 获取Thread的parkBlocker字段的内存偏移地址</span><br>            parkBlockerOffset = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;parkBlocker&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomSeed字段的内存偏移地址</span><br>            SEED = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSeed&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomProbe字段的内存偏移地址</span><br>            PROBE = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomProbe&quot;</span>));<br>            <span class="hljs-comment">// 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址</span><br>            SECONDARY = UNSAFE.objectFieldOffset<br>                (tk.getDeclaredField(<span class="hljs-string">&quot;threadLocalRandomSecondarySeed&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LockSupport中的方法<br><img src="https://img-blog.csdnimg.cn/direct/b347a036d85d44ba99175a57660ba7a9.png" alt="在这里插入图片描述">重点在于以下两种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAbsolute, <span class="hljs-type">long</span> time)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br></code></pre></td></tr></table></figure><p>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞:<br>① 调用unpark函数，释放该线程的许可。<br>② 该线程被中断。<br>③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活</p><p>LockSupport示例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (() -&gt; &#123;<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;开始运行&quot;</span>);<br>        LockSupport.park ();<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;解除park&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;线程一&quot;</span>);<br>    <br>    t1.start ();<br>    <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (() -&gt; &#123;<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;开始运行&quot;</span>);<br>        LockSupport.unpark (t1);<br>        System.out.println (Thread.currentThread ().getName () + <span class="hljs-string">&quot;解除线程一的park&quot;</span>);<br>    &#125;, <span class="hljs-string">&quot;线程二&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">线程二开始运行<br>线程一开始运行<br>线程二解除线程一的park<br>线程一解除park<br></code></pre></td></tr></table></figure><p>注意观察，LockSupport只需要在该停止的地方park一下，不需要创建任何锁的对象，也不需要关注是否该线程拥有锁，只需要LockSupport.park().然后静静等待通知。<br>还有一点值得注意的是，我们通过观察结果发现，线程二先开始运行，意味着它先一步通知了，但是线程一没有卡住，仍然收到了通知。解除了park.<br>这就是他的优秀之处。</p>]]></content>
    
    
    <categories>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>risc-v OS学习记录</title>
    <link href="/2023/10/19/risc-vOS%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/19/risc-vOS%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>学习资料：</p><p>gdb调试   <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">linuxtools</a></p><p>make 小知识 </p><p>​1   利用-n 可以看到详细的makefile的输出</p><p>寄存器小知识</p><blockquote><p>RISC-V 架构中有一组通用寄存器（General-Purpose Registers），它们通常用于存储整数数据和执行算术操作。以下是一些常见的 RISC-V 通用寄存器及其典型的作用：</p><ol><li><strong>x0</strong>：零寄存器，总是包含值0。在某些情况下，也被称为<code>zero</code>寄存器。</li><li><strong>x1</strong>：保留寄存器，用于汇编器、链接器等工具。</li><li><strong>x2</strong> - <strong>x11</strong>：临时寄存器，通常用于存储临时数据和计算结果。</li><li><strong>x12</strong> - <strong>x17</strong>：保存寄存器（s0 - s5），通常用于保存函数调用期间的寄存器值，以便在函数返回后能够正确恢复。</li><li><strong>x18</strong> - <strong>x27</strong>：临时寄存器，类似于 x2 - x11，用于存储临时数据。</li><li><strong>x28</strong> - <strong>x31</strong>：临时寄存器，通常用于存储临时数据和计算结果。</li></ol><p>除了通用寄存器，RISC-V 架构还包括一些特殊寄存器，这些寄存器在特定的操作和功能中发挥重要作用，例如：</p><ul><li><strong>pc</strong>：程序计数器，用于存储当前指令的地址，控制程序的执行顺序。</li><li><strong>sp</strong>：栈指针，用于管理函数调用期间的堆栈。</li><li><strong>gp</strong>：全局指针，通常用于访问全局数据。</li><li><strong>tp</strong>：线程指针，用于多线程环境中跟踪线程相关的数据。</li><li><strong>fp</strong>：帧指针，用于存储函数的栈帧信息。</li><li><strong>ra</strong>：返回地址寄存器，用于存储函数返回时的返回地址。</li><li><strong>a0</strong> - <strong>a7</strong>：参数寄存器，用于传递函数参数。</li><li><strong>t0</strong> - <strong>t6</strong>：临时寄存器，类似于通用寄存器，用于存储临时数据和计算结果。</li><li><strong>sstatus</strong>：状态寄存器，用于控制和管理处理器的状态，如中断和异常处理。</li><li><strong>stvec</strong>：中断向量寄存器，指示中断处理程序的入口地址。</li><li><strong>sie</strong>：中断使能寄存器，用于允许或禁止中断的发生。</li><li><strong>sip</strong>：中断挂起寄存器，用于标记中断请求的状态。</li><li><strong>mstatus</strong>：机器模式状态寄存器，类似于 <code>sstatus</code>，但用于机器模式下。</li><li><strong>mcause</strong>：机器模式异常原因寄存器，存储最近的异常原因。</li><li><strong>mtvec</strong>：机器模式中断向量寄存器，指示异常处理程序的入口地址。</li><li><strong>mepc</strong>：机器模式程序计数器，用于保存机器模式下的程序计数器值。</li></ul><p>这些寄存器在 RISC-V 架构中的不同模式下（用户模式、机器模式等）具有不同的行为和作用，但通常用于管理程序的执行、存储数据和处理中断与异常等任务。</p></blockquote><h3 id="00-bootstrap"><a href="#00-bootstrap" class="headerlink" title="00-bootstrap"></a>00-bootstrap</h3><p>这个项目下总共有四个文件夹分别是</p><p>首先看.h文件</p><h4 id="platform-h"><a href="#platform-h" class="headerlink" title="platform.h"></a>platform.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __PLATFORM_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PLATFORM_H__</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * QEMU RISC-V Virt machine with 16550a UART and VirtIO MMIO</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * maximum number of CPUs</span><br><span class="hljs-comment"> * see https://github.com/qemu/qemu/blob/master/include/hw/riscv/virt.h</span><br><span class="hljs-comment"> * #define VIRT_CPUS_MAX 8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM_CPU 8 <span class="hljs-comment">//这里的 8 应该是对应的hart的数量</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __PLATFORM_H__ */</span></span><br></code></pre></td></tr></table></figure><h4 id="start-S"><a href="#start-S" class="headerlink" title="start.S"></a>start.S</h4><p>注意是大写的S,可以包含#include 等指令，小写的则不行，它的作用是，在进入C语言的main函数中，初始化一些内容，比如hart的栈空间，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#include &quot;platform.h&quot;  //将.h文件包含<br><br># size of each hart&#x27;s stack is 1024 bytes<br>.equSTACK_SIZE, 1024 #.equ是汇编器识别的伪指令，作用是定义一个symble lable，值为1024<br><br>#定义全局的标签，是给链接器看的，告诉qemu从这里开始执行第一条指令<br>.global_start<br><br>.text<br>_start:<br># park harts with id != 0<br><br>#csrr是专门用来访问状态寄存器的<br><br>csrrt0, mhartid# read current hart id<br>mvtp, t0# keep CPU&#x27;s hartid in its tp for later usage.<br>bnezt0, park# if we&#x27;re not on the hart 0<br># we park the hart<br># Setup stacks, the stack grows from bottom to top, so we put the<br># stack pointer to the very end of the stack range.<br><br>//后面这些指令是为了不同的hart设置不同的栈空间，但是应该用不上<br>sllit0, t0, 10# shift left the hart id by 1024<br>lasp, stacks + STACK_SIZE# set the initial stack pointer<br># to the end of the first stack space<br>addsp, sp, t0# move the current hart stack pointer<br># to its place in the stack space<br><br>jstart_kernel# hart 0 jump to c<br><br>park:<br>wfi //是一种用来休眠的指令，避免空转耗电<br>jpark<br><br>stacks:<br>.skipSTACK_SIZE * MAXNUM_CPU # allocate space for all the harts stacks<br><br>.end# End of file<br><br></code></pre></td></tr></table></figure><h4 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//跳进来了以后开始空转</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">start_kernel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;; <span class="hljs-comment">// stop here!</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>makefile 的输出</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">riscv64-unknown-elf-gcc \<br>-nostdlib \<br>-fno-builtin \<br>-march=rv32ima \ <br>-mabi=ilp32 \ <br>-g <br>-Wall <br>-c <br>-o start.o start.S<br><br></code></pre></td></tr></table></figure><blockquote><p>这是一个编译命令，用于将 RISC-V 32位体系结构的汇编文件 <code>start.S</code> 编译成目标文件 <code>start.o</code>。以下是对该命令的各个部分的解释：</p><ul><li><p><code>riscv64-unknown-elf-gcc</code>: 这是 RISC-V 交叉编译工具链（Cross-Compiler）的命令前缀。<code>riscv64-unknown-elf-gcc</code> 表示使用的是针对 RISC-V 体系结构的交叉编译器。这个编译器可用于编译 RISC-V 架构的程序。</p></li><li><p><code>-nostdlib</code>: 这是一个编译选项，指示编译器不要链接标准 C 库。通常，嵌入式系统或嵌入式应用程序可能不需要完整的标准库，因此可以使用此选项来禁用标准库的链接。</p></li><li><p><code>-fno-builtin</code>: 这也是一个编译选项，用于禁用内建函数（Builtin Functions）的使用。内建函数是编译器内置的一些函数，它们通常用于执行特定操作，如优化。使用此选项可以禁用这些内建函数。</p></li><li><p><code>-march=rv32ima</code>: 这是一个编译选项，指定了目标架构。在这里，<code>-march=rv32ima</code> 表示目标架构是 RISC-V 32位，支持整数（i）、乘法扩展（m）和原子操作扩展（a）指令集。</p></li><li><p><code>-mabi=ilp32</code>: 这是另一个编译选项，指定了目标 ABI（Application Binary Interface）。<code>ilp32</code> 表示整数类型、寄存器和地址都是32位的。这与 <code>lp64</code>（长整数类型、寄存器和地址为64位）等不同的 ABI 有关。</p></li><li><p><code>-g</code>: 这是一个编译选项，用于生成调试信息。它会在目标文件中嵌入调试信息，以便在后续调试程序时使用。</p></li><li><p><code>-Wall</code>: 这是一个编译选项，用于启用编译器的警告。编译器将生成警告消息，以帮助开发人员识别潜在的问题或错误。</p></li><li><p><code>-c</code>: 这是一个编译选项，指示编译器仅生成目标文件，而不进行链接操作。生成的目标文件通常具有 <code>.o</code> 扩展名。</p></li><li><p><code>-o start.o</code>: 这是一个编译选项，指定生成的目标文件的名称。在这里，生成的目标文件将命名为 <code>start.o</code>。</p></li></ul><p>总的来说，这个编译命令用于将 RISC-V 32位汇编文件 <code>start.S</code> 编译成目标文件 <code>start.o</code>，使用了特定的目标架构和 ABI，并启用了调试信息和警告。这是编译一个 RISC-V 32位汇编程序的标准命令。后续可以使用该目标文件进行链接操作，以创建可执行文件。</p></blockquote><h3 id="01-HelloRVOS"><a href="#01-HelloRVOS" class="headerlink" title="01-HelloRVOS"></a>01-HelloRVOS</h3><p>想办法打印出一个hello world</p>]]></content>
    
    
    <categories>
      
      <category>risc-V</category>
      
    </categories>
    
    
    <tags>
      
      <tag>risc-v</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sql窗口函数</title>
    <link href="/2022/09/28/Sql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2022/09/28/Sql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数语法"><a href="#窗口函数语法" class="headerlink" title="窗口函数语法"></a>窗口函数语法</h2><p>SQL窗口函数是SQL中的一种高级函数，它允许用户在不显式分组查询的情况下对结果集进行分组和聚合计算。<br> 窗口函数的特别之处在于，它们将结果集中的每一行看作一个单独的计算对象，而不是将结果集划分为分组并计算每个分组的聚合值。这就使得窗口函数能够为结果集中的每一行计算类似排名、行号、百分比和移动聚合函数等值。</p><p><strong>SQL窗口函数的语法如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-operator">&lt;</span>窗口函数<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">OVER</span> ([<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>分组列<span class="hljs-operator">&gt;</span> [, <span class="hljs-operator">&lt;</span>分组列<span class="hljs-operator">&gt;</span>...]]<br><br>                     [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-operator">&lt;</span>排序列<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>] [, <span class="hljs-operator">&lt;</span>排序列<span class="hljs-operator">&gt;</span> [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>]]...]<br><br>                     [<span class="hljs-operator">&lt;</span><span class="hljs-keyword">rows</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">range</span> clause<span class="hljs-operator">&gt;</span>])<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>&lt;窗口函数&gt;</code> : 定义要在窗口中计算的聚合函数或其它分析函数，如COUNT、RANK、SUM等。</li><li><code>OVER</code> : 窗口函数的核心关键字。</li><li><code>PARTITION BY</code> : 定义要用来分组的一组列名。</li><li><code>ORDER BY</code> : 定义用来排序的一组列名。</li><li><code>&lt;rows or range clause&gt;</code> : 定义窗口的行集合。默认为  <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code> ，表示窗口包括从窗口开始到当前行的所有行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemctl命令介绍和使用</title>
    <link href="/2020/09/28/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/09/28/systemctl%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Systemd程序"><a href="#Systemd程序" class="headerlink" title="Systemd程序"></a>Systemd程序</h3><p>Systemd其实是Linux系统用来管理系统的一个程序，用来代替原来的init进程(用来管理启动系统其它的服务进程)，现在很多Linux发行版都已经自带Systemd程序了。</p><h3 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h3><h4 id="1-Unit"><a href="#1-Unit" class="headerlink" title="1. Unit"></a>1. Unit</h4><p>systemctl命令是Systemd中最重要的一个命令，用于对服务进行启动，停止等操作，在Systemd中有Unit的概念，每个进程都是一个Unit，总共有十二种Unit类型。</p><ul><li>Service unit，系统服务</li><li>Target unit，多个 Unit 构成的一个组</li><li>Device Unit，硬件设备</li><li>Mount Unit，文件系统的挂载点</li><li>Automount Unit，自动挂载点</li><li>Path Unit，文件或路径</li><li>Scope Unit，不是由 Systemd 启动的外部进程</li><li>Slice Unit，进程组</li><li>Snapshot Unit，Systemd 快照，可以切回某个快照</li><li>Socket Unit，进程间通信的 socket</li><li>Swap Unit，swap 文件</li><li>Timer Unit，定时器</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 列出正在运行的Unit<br>systemctl list<span class="hljs-operator">-</span>units，可以直接使用systemctl<br><br># 列出所有Unit，包括没有找到配置文件的或者启动失败的<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--all</span><br><br># 列出所有没有运行的 Unit<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--all --state=inactive</span><br><br># 列出所有加载失败的 Unit<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--failed</span><br><br># 列出所有正在运行的、类型为service的Unit<br>systemctl list<span class="hljs-operator">-</span>units <span class="hljs-comment">--type=service</span><br><br># 显示某个 Unit 是否正在运行<br>systemctl <span class="hljs-keyword">is</span><span class="hljs-operator">-</span>active application.service<br><br># 显示某个 Unit 是否处于启动失败状态<br>systemctl <span class="hljs-keyword">is</span><span class="hljs-operator">-</span>failed application.service<br><br># 显示某个 Unit 服务是否建立了启动链接<br>systemctl <span class="hljs-keyword">is</span><span class="hljs-operator">-</span>enabled application.service<br><br># 立即启动一个服务<br>sudo systemctl <span class="hljs-keyword">start</span> apache.service<br><br># 立即停止一个服务<br>sudo systemctl stop apache.service<br><br># 重启一个服务<br>sudo systemctl restart apache.service<br><br># 重新加载一个服务的配置文件<br>sudo systemctl reload apache.service<br><br># 重载所有修改过的配置文件<br>sudo systemctl daemon<span class="hljs-operator">-</span>reload<br></code></pre></td></tr></table></figure><h3 id="systemctl中Unit的配置文件"><a href="#systemctl中Unit的配置文件" class="headerlink" title="systemctl中Unit的配置文件"></a>systemctl中Unit的配置文件</h3><p>上面说了每个服务都是一个Unit，那每个Unit都会有它的配置文件，这样启动的时候才知道要按照什么方式去启动。Systemd默认从目录<code>/etc/systemd/system/</code>读取配置文件。但是里面存放的大部分文件都是符号链接，指向目录<code>/usr/lib/systemd/system/</code>，真正的配置文件存放在那个目录。</p><h4 id="1-查看Unit的配置文件"><a href="#1-查看Unit的配置文件" class="headerlink" title="1. 查看Unit的配置文件"></a>1. 查看Unit的配置文件</h4><p>可以使用<code>systemctl cat</code>命令来查看服务的配置文件，下面是Mysql的配置文件，很多软件已经支持Systemd程序了，安装的时候会自动配置它的Unit配置文件，例如Mysql和Nginx等等。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[root@VM_0_11_centos ~]</span><span class="hljs-comment"># systemctl cat mysqld</span><br><span class="hljs-comment"># /usr/lib/systemd/system/mysqld.service</span><br><br><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=MySQL Server<br><span class="hljs-attr">Documentation</span>=man:mysqld(<span class="hljs-number">8</span>)<br><span class="hljs-attr">Documentation</span>=http://dev.mysql.com/doc/refman/en/using-systemd.html<br><span class="hljs-attr">After</span>=network.target<br><span class="hljs-attr">After</span>=syslog.target<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">User</span>=mysql<br><span class="hljs-attr">Group</span>=mysql<br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">PIDFile</span>=/var/run/mysqld/mysqld.pid<br><span class="hljs-comment"># Disable service start and stop timeout logic of systemd for mysqld service.</span><br><span class="hljs-attr">TimeoutSec</span>=<span class="hljs-number">0</span><br><span class="hljs-comment"># Execute pre and post scripts as root</span><br><span class="hljs-attr">PermissionsStartOnly</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment"># Needed to create system tables</span><br><span class="hljs-attr">ExecStartPre</span>=/usr/bin/mysqld_pre_systemd<br><span class="hljs-comment"># Start main service</span><br><span class="hljs-attr">ExecStart</span>=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid <span class="hljs-variable">$MYSQLD_OPTS</span><br><span class="hljs-comment"># Use this to switch malloc implementation</span><br><span class="hljs-attr">EnvironmentFile</span>=-/etc/sysconfig/mysql<br><span class="hljs-comment"># Sets open_files_limit</span><br><span class="hljs-attr">LimitNOFILE</span> = <span class="hljs-number">5000</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartPreventExitStatus</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">false</span><br><br></code></pre></td></tr></table></figure><h4 id="2-Unit配置文件的含义"><a href="#2-Unit配置文件的含义" class="headerlink" title="2. Unit配置文件的含义"></a>2. Unit配置文件的含义</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown">可以看到Unit配置文件有很多标签，不同的标签都代表了不同的意思，这里只列出部分介绍，可以去官网查看Unit配置文件文档介绍，https://www.freedesktop.org/software/systemd/man/systemd.unit.html。<br><br><span class="hljs-bullet">-</span> Unit<br><span class="hljs-bullet">   -</span> Description，服务的描述<br><span class="hljs-bullet">   -</span> Documentation，文档介绍<br><span class="hljs-bullet">   -</span> After，该服务要在什么服务启动之后启动，比如Mysql需要在network和syslog启动之后再启动<br><span class="hljs-bullet">-</span> Install<br><span class="hljs-bullet">   -</span> WantedBy，值是一个或多个Target，当前Unit激活时(enable)符号链接会放入/etc/systemd/system目录下面以Target名+.wants后缀构成的子目录中<br><span class="hljs-bullet">   -</span> RequiredBy，它的值是一个或多个Target，当前Unit激活(enable)时，符号链接会放入/etc/systemd/system目录下面以Target名+.required后缀构成的子目录中<br><span class="hljs-bullet">   -</span> Alias，当前Unit可用于启动的别名<br><span class="hljs-bullet">   -</span> Also，当前Unit激活(enable)时，会被同时激活的其他Unit<br><span class="hljs-bullet">-</span> Service<br><span class="hljs-bullet">   -</span> Type，定义启动时的进程行为。它有以下几种值。<br><span class="hljs-bullet">   -</span> Type=simple，默认值，执行ExecStart指定的命令，启动主进程<br><span class="hljs-bullet">   -</span> Type=forking，以 fork 方式从父进程创建子进程，创建后父进程会立即退出<br><span class="hljs-bullet">   -</span> Type=oneshot，一次性进程，Systemd 会等当前服务退出，再继续往下执行<br><span class="hljs-bullet">   -</span> Type=dbus，当前服务通过D-Bus启动<br><span class="hljs-bullet">   -</span> Type=notify，当前服务启动完毕，会通知Systemd，再继续往下执行<br><span class="hljs-bullet">   -</span> Type=idle，若有其他任务执行完毕，当前服务才会运行<br><span class="hljs-bullet">   -</span> ExecStart，启动当前服务的命令<br><span class="hljs-bullet">   -</span> ExecStartPre，启动当前服务之前执行的命令<br><span class="hljs-bullet">   -</span> ExecStartPost，启动当前服务之后执行的命令<br><span class="hljs-bullet">   -</span> ExecReload，重启当前服务时执行的命令<br><span class="hljs-bullet">   -</span> ExecStop，停止当前服务时执行的命令<br><span class="hljs-bullet">   -</span> ExecStopPost，停止当其服务之后执行的命令<br><span class="hljs-bullet">   -</span> RestartSec，自动重启当前服务间隔的秒数<br><span class="hljs-bullet">   -</span> Restart，定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog<br><span class="hljs-bullet">   -</span> TimeoutSec，定义 Systemd 停止当前服务之前等待的秒数<br><span class="hljs-bullet">   -</span> Environment，指定环境变量<br></code></pre></td></tr></table></figure><h3 id="自定义服务启动"><a href="#自定义服务启动" class="headerlink" title="自定义服务启动"></a>自定义服务启动</h3><p>既然Systemd的作用就是控制服务的启动，那么就可以把自己的服务添加进去，就可以直接使用systemctl命令来控制服务的启动，或者是设置开机自动启动等等。</p><p>在<code>/usr/lib/systemd/system</code>目录中创建自己的配置文件，一般都是<code>.service</code>结尾，例如这里创建了一个<code>test-sh.service</code>配置文件，这个Unit是为了启动我们自己的一个shell脚本。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># /usr/lib/systemd/system/test-sh.service</span><br><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>= test sh log<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">ExecStart</span>=/opt/dev/shell/test.sh<br><span class="hljs-attr">Type</span>=forking<br><span class="hljs-attr">KillMode</span>=process<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">30</span>s<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br><br></code></pre></td></tr></table></figure><h4 id="2-创建脚本"><a href="#2-创建脚本" class="headerlink" title="2. 创建脚本"></a>2. 创建脚本</h4><p>在上面配置文件指定的启动路径<code>/opt/dev/shell/</code>下创建shell脚本，这里只是每秒打印当前时间，并输出到一个文本中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br><span class="hljs-built_in">sleep</span> 1<br> <span class="hljs-built_in">date</span>=`<span class="hljs-built_in">date</span> -d today +<span class="hljs-string">&quot;%Y-%m-%d %T&quot;</span>`<br> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;date&#125;</span> &gt;&gt; /opt/dev/shell/test.txt<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h4 id="3-载入配置文件并启动"><a href="#3-载入配置文件并启动" class="headerlink" title="3. 载入配置文件并启动"></a>3. 载入配置文件并启动</h4><p>使用<code>systemctl daemon-reload</code>命令来载入新添加的配置文件，然后使用<code>systemctl start test-sh.service</code>命令启动，再使用<code>systemctl status test-sh.service</code>命令来查看状态，可以看到已经启动，<code>/opt/dev/shell/test.txt</code>也确实在不停的写入内容，最后使用<code>systemctl stop test-sh.service</code>命令停止服务，可以看到状态也是停止了。</p><p>注意的是修改配置文件后一定要使用<code>systemctl daemon-reload</code>命令来载入新添加的配置文件，然后再启动服务。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl start test-sh.service</span><br>^C<br>[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl status test-sh.service</span><br>● test-sh.service - test sh log<br>   Loaded: loaded (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/test-sh.service; enabled; vendor preset: disabled)<br>   Active: activating (start) since Fri <span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">46</span>:<span class="hljs-number">45</span> CST; <span class="hljs-number">11</span>s ago<br>   Control: <span class="hljs-number">9295</span> (test.sh)<br>   CGroup: <span class="hljs-regexp">/system.slice/</span>test-sh.service<br>       ├─<span class="hljs-number">9295</span> <span class="hljs-regexp">/bin/</span>bash <span class="hljs-regexp">/opt/</span>dev<span class="hljs-regexp">/shell/</span>test.sh<br>       └─<span class="hljs-number">9343</span> sleep <span class="hljs-number">1</span><br><br>Jun <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">46</span>:<span class="hljs-number">45</span> VM_0_11_centos systemd[<span class="hljs-number">1</span>]: Starting test sh log...<br>[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl stop test-sh.service</span><br>[root@VM_0_11_centos ~]<span class="hljs-comment"># systemctl status test-sh.service</span><br>● test-sh.service - test sh log<br>   Loaded: loaded (<span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/systemd/</span>system/test-sh.service; enabled; vendor preset: disabled)<br>   Active: inactive (dead) since Fri <span class="hljs-number">2020</span>-<span class="hljs-number">06</span>-<span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52</span> CST; <span class="hljs-number">2</span>s ago<br>  Process: <span class="hljs-number">9295</span> ExecStart=<span class="hljs-regexp">/opt/</span>dev<span class="hljs-regexp">/shell/</span>test.sh (code=killed, signal=TERM)<br><br>Jun <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">46</span>:<span class="hljs-number">45</span> VM_0_11_centos systemd[<span class="hljs-number">1</span>]: Starting test sh log...<br>Jun <span class="hljs-number">26</span> <span class="hljs-number">05</span>:<span class="hljs-number">47</span>:<span class="hljs-number">52</span> VM_0_11_centos systemd[<span class="hljs-number">1</span>]: Stopped test sh log.<br></code></pre></td></tr></table></figure><h3 id="查看Unit启动日志"><a href="#查看Unit启动日志" class="headerlink" title="查看Unit启动日志"></a>查看Unit启动日志</h3><p>Systemd统一管理了所有Unit的启动日志，因此只需要使用journalctl命令就可以查看到服务的日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查看所有日志（默认情况下 ，只保存本次启动的日志）<br>journalctl<br><br># 查看指定时间的日志<br>journalctl <span class="hljs-comment">--since=&quot;2012-10-30 18:17:16&quot;</span><br>journalctl <span class="hljs-comment">--since &quot;20 min ago&quot;</span><br>journalctl <span class="hljs-comment">--since yesterday</span><br>journalctl <span class="hljs-comment">--since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br>journalctl <span class="hljs-comment">--since 09:00 --until &quot;1 hour ago&quot;</span><br><br># 显示尾部的最新<span class="hljs-number">10</span>行日志<br>journalctl <span class="hljs-operator">-</span>n<br><br># 显示尾部指定行数的日志<br>journalctl <span class="hljs-operator">-</span>n <span class="hljs-number">20</span><br><br># 实时滚动显示最新日志<br>journalctl <span class="hljs-operator">-</span>f<br><br># 查看指定服务的日志<br>journalctl <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>lib<span class="hljs-operator">/</span>systemd<span class="hljs-operator">/</span>systemd<br><br># 查看指定进程的日志<br>journalctl _PID<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><br># 查看某个路径的脚本的日志<br>journalctl <span class="hljs-operator">/</span>usr<span class="hljs-operator">/</span>bin<span class="hljs-operator">/</span>bash<br><br># 查看指定用户的日志<br>journalctl _UID<span class="hljs-operator">=</span><span class="hljs-number">33</span> <span class="hljs-comment">--since today</span><br><br># 查看某个 Unit 的日志<br>journalctl <span class="hljs-operator">-</span>u nginx.service<br>journalctl <span class="hljs-operator">-</span>u nginx.service <span class="hljs-comment">--since today</span><br><br># 实时滚动显示某个 Unit 的最新日志<br>journalctl <span class="hljs-operator">-</span>u nginx.service <span class="hljs-operator">-</span>f<br><br># 合并显示多个 Unit 的日志<br>$ journalctl <span class="hljs-operator">-</span>u nginx.service <span class="hljs-operator">-</span>u php<span class="hljs-operator">-</span>fpm.service <span class="hljs-comment">--since today</span><br></code></pre></td></tr></table></figure><blockquote><p>一天的光阴，能够写进我们记忆中的并不多，能够为人生带来些助益的，也不见得有多少。我们一直在求有所得，但却每一分每一秒都在错过。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输出的网络连接信息含义</title>
    <link href="/2020/09/27/%E8%BE%93%E5%87%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF%E5%90%AB%E4%B9%89/"/>
    <url>/2020/09/27/%E8%BE%93%E5%87%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一、ifconfig-与-ip-addr"><a href="#一、ifconfig-与-ip-addr" class="headerlink" title="一、ifconfig 与 ip addr"></a>一、ifconfig 与 ip addr</h3><p>用过Linux的读者都知道，在Linux查看ip可以使用ifconfig，当然这个ifconfig属于<code>net-tools</code> 工具集，其来源于BSD，Linux从2001年就不对其进行维护了。那我们应该用什么呢？还有<code>iproute2</code> 工具集，其功能更强大，我们今天就来讲讲该工具集的<code>ip addr</code>命令。</p><p>而运行ip addr命令，会出现类似下面的的内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>: lo: <span class="hljs-operator">&lt;</span>LOOPBACK,UP,LOWER_UP<span class="hljs-operator">&gt;</span> mtu <span class="hljs-number">65536</span> qdisc noqueue state <span class="hljs-literal">UNKNOWN</span> qlen <span class="hljs-number">1</span><br>    link<span class="hljs-operator">/</span>loopback <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> brd <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>    inet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-operator">/</span><span class="hljs-number">8</span> <span class="hljs-keyword">scope</span> host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::<span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-number">128</span> <span class="hljs-keyword">scope</span> host<br>       valid_lft forever preferred_lft forever<br><span class="hljs-number">2</span>: ens33: <span class="hljs-operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="hljs-operator">&gt;</span> mtu <span class="hljs-number">1500</span> qdisc pfifo_fast state UP qlen <span class="hljs-number">1000</span><br>    link<span class="hljs-operator">/</span>ether <span class="hljs-number">00</span>:<span class="hljs-number">0</span>c:<span class="hljs-number">62</span>:<span class="hljs-number">3</span>c:<span class="hljs-number">62</span>:a1 brd ff:ff:ff:ff:ff:ff<br>    inet <span class="hljs-number">192.168</span><span class="hljs-number">.108</span><span class="hljs-number">.19</span><span class="hljs-operator">/</span><span class="hljs-number">24</span> brd <span class="hljs-number">192.168</span><span class="hljs-number">.108</span><span class="hljs-number">.255</span> <span class="hljs-keyword">scope</span> <span class="hljs-keyword">global</span> ens33<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::<span class="hljs-number">5</span>df:<span class="hljs-number">3</span>b5f:e5fe:ddc2<span class="hljs-operator">/</span><span class="hljs-number">64</span> <span class="hljs-keyword">scope</span> link<br>       valid_lft forever preferred_lft forever<br><br></code></pre></td></tr></table></figure><h4 id="二、IP地址"><a href="#二、IP地址" class="headerlink" title="二、IP地址"></a>二、IP地址</h4><h5 id="1）网络地址"><a href="#1）网络地址" class="headerlink" title="1）网络地址"></a>1）网络地址</h5><p>IP地址由网络号（包括子网号）+主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p><h5 id="2）广播地址"><a href="#2）广播地址" class="headerlink" title="2）广播地址"></a>2）广播地址</h5><p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p><p>广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p><p>255.255.255.255：该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。</p><h5 id="3）组播地址"><a href="#3）组播地址" class="headerlink" title="3）组播地址"></a>3）组播地址</h5><p>D类地址就是组播地址。</p><blockquote><p>A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0<del>127.255.255.255；<br>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0</del>191.255.255.255;<br>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0<del>223.255.255.255。<br>D类地址以1110开头，地址范围是224.0.0.0</del>239.255.255.255，D类地址作为组播地址（一对多的通信）；<br>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p></blockquote><p>注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p><h5 id="4）0-0-0-0"><a href="#4）0-0-0-0" class="headerlink" title="4）0.0.0.0"></a>4）0.0.0.0</h5><p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p><h5 id="5）回环地址"><a href="#5）回环地址" class="headerlink" title="5）回环地址"></a>5）回环地址</h5><p>127.0.0.0&#x2F;8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p><h5 id="6）A、B、C类私有地址"><a href="#6）A、B、C类私有地址" class="headerlink" title="6）A、B、C类私有地址"></a>6）A、B、C类私有地址</h5><blockquote><p> 私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p></blockquote><blockquote><p>A类私有地址：10.0.0.0&#x2F;8，范围是：10.0.0.0~10.255.255.255</p></blockquote><blockquote><p>B类私有地址：172.16.0.0&#x2F;12，范围是：172.16.0.0~172.31.255.255</p></blockquote><blockquote><p>C类私有地址：192.168.0.0&#x2F;16，范围是：192.168.0.0~192.168.255.255</p></blockquote><p>了解以上内容之后，再看其中的<code>192.168.108.19/24</code>便是<code>IPv4</code>的地址，这个地址由4个部分组成，每个部分8个bit，<strong>因此整个地址空间有 4 294 967 296（232232）个地址，也就是近43亿个地址。</strong> 地球上的人口都比这个多，何况我们很多人都不止使用一个IP地址吧？何况<strong>还有一些地址是作为特殊用途而保留的，如局域网专用地址（约1800万个地址）和组播地址（约2700万个地址）</strong> 。这样IPv4能够使用的地址就更少了，所有我们有了IPv6，IPv6有128位，其地址空间有340282366920938463463374607431768211456个地址，我觉得暂时是够了。128位有点长，于是采用16进制来描述IPv6地址，所有看起来IPv6的地址只有32位。</p><p>那么IPv4后面斜杠&#x2F;以及后面的数字代表什么意思呢？这就和CIDR又关系了，<code>192.168.108.19/24</code>说明前24位是网络号，后8位是主机号。通过这种方式，它根据用户的要求根据某些规则动态分配IP地址。</p><p>还有一种叫做子网掩码的东西，将子网掩码与IP地址做与运算，就能得到网络号。</p><p><strong>CIDR使IP地址从三级编址(使用子网掩码)，又回到了两级编址，但这已是无分类的两级编址。</strong></p><h4 id="三、MAC地址"><a href="#三、MAC地址" class="headerlink" title="三、MAC地址"></a>三、MAC地址</h4><p>在命令输出结果中<code>link/ether 00:0c:62:3c:62:a1 brd ff:ff:ff:ff:ff:ff</code>代表MAC地址，是网卡的物理地址，这个MAC地址是网卡出厂就确定了的，具有唯一性。</p><p>但是具有唯一性，不代表我们就干脆用它来进行通信，可以这样类比：MAC地址是我们的身份证号，而IP地址是我们身份证上的地址。</p><p>你要找一个远方的朋友进行联系，你用这个身份证号去问别人，是不是没人知道，而用家庭地址一步一步去找，是不是肯定能找到。</p><p>那么MAC地址是不是就没用了呢，不是！其具有通信作用，你想想，你去问朋友的家人，这个身份证号是谁，他是不是能够知道。MAC地址的通信范围只能在一个子网中，只要跨子网，MAC地址就没有作用了。</p><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><h5 id="4-1-scope"><a href="#4-1-scope" class="headerlink" title="4.1 scope"></a>4.1 scope</h5><p><code>inet 192.168.108.19/24 brd 192.168.108.255 scope global ens33</code>这里面scope代表作用范围，ens33这张网卡这里查询是global，说明可以接受全局的包，哪里的包都接受。而lo网卡查询的scope是host，说明该网卡只能在本机通信。</p><h5 id="4-2-lo"><a href="#4-2-lo" class="headerlink" title="4.2 lo"></a>4.2 lo</h5><p>lo代表<strong>loopback</strong>，是虚拟接口，是一种纯软件性质的虚拟接口。任何送到该接口的网络数据报文都会被认为是送往设备自身的。</p><h5 id="4-3-lt-BROADCAST-MULTICAST-UP-LOWER-UP-gt"><a href="#4-3-lt-BROADCAST-MULTICAST-UP-LOWER-UP-gt" class="headerlink" title="4.3  &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;"></a>4.3  &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="hljs-operator">&gt;</span> mtu <span class="hljs-number">1500</span> qdisc pfifo_fast state UP qlen <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p><code>&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</code>这个东西是<strong>net_device flags</strong>，<strong>网络设备的状态标识</strong>。</p><blockquote><p>BROADCAST   该接口支持广播</p><p>MULTICAST   该接口支持多播</p><p>UP          网络接口已启用</p><p>LOWER_UP    网络电缆已插入，设备已连接至网络</p></blockquote><h5 id="4-4-MTU"><a href="#4-4-MTU" class="headerlink" title="4.4 MTU"></a>4.4 MTU</h5><p>至于<code>mtu 1500</code>是指最大传输单元MTU（Maximum Transmission Unit，MTU），表示网络可以传输的最大数据包大小，以字节为单位。</p><p>MTU的大小决定了发送端一次能够发送报文的最大字节数。如果MTU超过了接收端所能够承受的最大值，或者是超过了发送路径上途经的某台设备所能够承受的最大值，就会造成报文分片甚至丢弃，加重网络传输的负担。如果太小，那实际传送的数据量就会过小，影响传输效率。</p><h5 id="4-5-QDisk"><a href="#4-5-QDisk" class="headerlink" title="4.5 QDisk"></a>4.5 QDisk</h5><p><code>qdisc pfifo_fast</code>中，QDisk是queueing discipline的简写，即排队规则。</p><p>这篇文章对排队规则介绍得非常好：[<a href="https://link.juejin.cn/?target=http://arthurchiao.art/blog/lartc-qdisc-zh/%2391-%E9%98%9F%E5%88%97queues%E5%92%8C%E6%8E%92%E9%98%9F%E8%A7%84%E5%88%99queueing-disciplines">译] 《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽 (arthurchiao.art)</a></p><h5 id="4-6-statu"><a href="#4-6-statu" class="headerlink" title="4.6 statu"></a>4.6 statu</h5><p><code>state UP</code>表示网络接口已启用。</p><h5 id="4-7-Qlen"><a href="#4-7-Qlen" class="headerlink" title="4.7 Qlen"></a>4.7 Qlen</h5><p><code>qlen 1000</code>，Qlen代表传输队列长度，此处为1000。</p><h5 id="4-8-valid-lft-amp-preferred-lft"><a href="#4-8-valid-lft-amp-preferred-lft" class="headerlink" title="4.8 valid_lft &amp; preferred_lft"></a>4.8 valid_lft &amp; preferred_lft</h5><p>valid_lft forever IPv4&#x2F;IPv6 地址的有效使用期限</p><p>preferred_lft forever IPv4&#x2F;IPv6 地址的首选生存期</p><blockquote><p>一天的光阴，能够写进我们记忆中的并不多，能够为人生带来些助益的，也不见得有多少。我们一直在求有所得，但却每一分每一秒都在错过。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ip</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
